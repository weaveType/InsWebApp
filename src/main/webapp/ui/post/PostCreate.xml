<?xml version="1.0" encoding="UTF-8"?>
<html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:ev="http://www.w3.org/2001/xml-events"
    xmlns:w2="http://www.inswave.com/websquare" 
    xmlns:xf="http://www.w3.org/2002/xforms">
    
    <head meta_screenName="공고 등록">
        <w2:type>COMPONENT</w2:type>
        <w2:buildDate/>
        <w2:MSA/>
        <xf:model>
            <w2:dataCollection baseNode="map">
                <!-- 선택된 기술스택 목록 (CreatePosting.xml과 동일한 순서로 먼저 배치) -->
                <w2:dataList baseNode="list" repeatNode="map" id="dlt_techstack" saveRemovedData="true">
                    <w2:columnInfo>
                        <w2:column dataType="text" name="techstack" id="techstack"></w2:column>
                    </w2:columnInfo>
                </w2:dataList>
                
                <!-- 선택된 성향 목록 -->
                <w2:dataList baseNode="list" repeatNode="map" id="dlt_personalities" saveRemovedData="true">
                    <w2:columnInfo>
                        <w2:column dataType="text" name="personality" id="personality"></w2:column>
                    </w2:columnInfo>
                </w2:dataList>
                
                <!-- 서버에서 가져온 전체 기술스택 목록 -->
                <w2:dataList baseNode="list" repeatNode="map" id="dlt_all_techstacks" saveRemovedData="true">
                    <w2:columnInfo>
                        <w2:column dataType="text" name="techStackId" id="techStackId"></w2:column>
                        <w2:column dataType="text" name="techStackName" id="techStackName"></w2:column>
                    </w2:columnInfo>
                </w2:dataList>
                
                <!-- 공고 기본 정보 (DataList들 이후에 배치) -->
                <w2:dataMap baseNode="map" id="dmp_postVo" style="">
                    <w2:keyInfo>
                        <w2:key dataType="text" id="jobPostingId" name="job_posting_id"></w2:key>
                        <w2:key dataType="text" id="companyId" name="company_id"></w2:key>
                        <w2:key dataType="text" id="title" name="title"></w2:key>
                        <w2:key dataType="text" id="description" name="description"></w2:key>
                        <w2:key dataType="text" id="selectedTechStackNames" name="selected_tech_stack_names"></w2:key>
                        <w2:key dataType="text" id="experienceLevel" name="experience_level"></w2:key>
                        <w2:key dataType="text" id="salaryRange" name="salary_range"></w2:key>
                        <w2:key dataType="text" id="location" name="location"></w2:key>
                        <w2:key dataType="text" id="workType" name="work_type"></w2:key>
                        <w2:key dataType="text" id="preferredDeveloperTypes" name="preferred_developer_types"></w2:key>
                        <w2:key dataType="text" id="expiresAt" name="expires_at"></w2:key>
                        <w2:key dataType="text" id="postedAt" name="posted_at"></w2:key>
                        <w2:key dataType="text" id="status" name="status"></w2:key>
                        <w2:key dataType="text" id="jobImageFileName" name="job_image_file_name"></w2:key>
                    </w2:keyInfo>
                </w2:dataMap>
            </w2:dataCollection>
            <w2:workflowCollection/>
            
            <!-- 공고 등록 submission -->
            <xf:submission id="sbm_insertPost" ref='data:json,{"id":"dmp_postVo","key":"postVo"}' target="" action="/InsWebApp/POS0001Ins.pwkjson" method="post"
                mediatype="application/json" encoding="UTF-8" instance="" replace="" errorHandler="" customHandler="" mode="asynchronous" processMsg="공고를 등록 중입니다."
                ev:submit="" ev:submitdone="scwin.sbm_insertPost_submitdone" ev:submiterror="" abortTrigger="">
            </xf:submission>
            
            <!-- 기술스택 목록 조회 submission -->
            <xf:submission id="sbm_selectTechStackList" ref="" target="" action="/InsWebApp/POS0002List.pwkjson" method="post"
                mediatype="application/json" encoding="UTF-8" instance="" replace="" errorHandler="" customHandler="" mode="asynchronous" processMsg="기술스택 목록을 불러오는 중입니다."
                ev:submit="" ev:submitdone="scwin.sbm_selectTechStackList_submitdone" ev:submiterror="" abortTrigger="">
            </xf:submission>
        </xf:model>
        <w2:layoutInfo/>
        <w2:publicInfo method=""/>
        
        <style type="text/css"><![CDATA[
/* 전체 컨테이너 스타일 */
.main-container {
    background-color: #ffffff;
    min-height: 100vh;
    padding: 40px 20px;
    max-width: 500px;
    margin: 0 auto;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
}

/* 페이지 제목 스타일 */
.page-title {
    text-align: center;
    margin-bottom: 60px;
}

.main-title {
    font-size: 28px;
    font-weight: 700;
    color: #333;
    margin: 0;
    letter-spacing: -0.5px;
}

.page-subtitle {
    font-size: 14px;
    color: #6b7280;
    margin: 8px 0 0 0;
}

/* 폼 컨테이너 */
.form-container {
    width: 100%;
}

/* 폼 그룹 스타일 */
.form-group {
    margin-bottom: 32px;
    position: relative;
}

.form-group.half {
    flex: 0 0 calc(50% - 10px);
}

.form-row {
    display: flex;
    gap: 20px;
    margin-bottom: 20px;
}

.form-label {
    display: block;
    font-size: 16px;
    font-weight: 600;
    color: #333;
    margin-bottom: 12px;
    letter-spacing: -0.3px;
}

/* 필수 항목 표시 스타일 */
.form-label.required::after {
    content: " *";
    color: #dc2626;
    font-weight: bold;
}

/* 입력 필드 스타일 */
.form-input {
    width: 100%;
    height: 56px;
    padding: 0 16px;
    border: 2px solid #e5e7eb;
    border-radius: 12px;
    font-size: 16px;
    color: #333;
    background-color: #ffffff;
    transition: all 0.2s ease;
    box-sizing: border-box;
}

.form-input:focus {
    outline: none;
    border-color: #3b82f6;
    box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
}

.form-input::placeholder {
    color: #9ca3af;
    font-weight: 400;
}

/* 텍스트 영역 스타일 */
.form-textarea {
    width: 100%;
    min-height: 120px;
    padding: 16px;
    border: 2px solid #e5e7eb;
    border-radius: 12px;
    font-size: 16px;
    color: #333;
    background-color: #ffffff;
    font-family: inherit;
    resize: vertical;
    transition: all 0.2s ease;
    box-sizing: border-box;
}

.form-textarea:focus {
    outline: none;
    border-color: #3b82f6;
    box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
}

.form-textarea::placeholder {
    color: #9ca3af;
    font-weight: 400;
}

/* 기술스택 관련 스타일 */
.techstack-input-container {
    display: flex;
    gap: 8px;
    align-items: center;
}

.techstack-input {
    flex: 1;
    height: 56px;
    padding: 0 16px;
    border: 2px solid #e5e7eb;
    border-radius: 12px;
    font-size: 16px;
    color: #333;
    background-color: #ffffff;
    transition: all 0.2s ease;
    box-sizing: border-box;
}

.techstack-input:focus {
    outline: none;
    border-color: #3b82f6;
    box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
}

.btn-add-techstack {
    height: 56px;
    padding: 0 20px;
    border: 2px solid #3b82f6;
    border-radius: 12px;
    background-color: #3b82f6;
    color: #ffffff;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
    white-space: nowrap;
    flex-shrink: 0;
}

.btn-add-techstack:hover {
    background-color: #2563eb;
    border-color: #2563eb;
}

/* 기술스택 그리드 */
.techstack-grid {
    min-height: 80px;
    padding: 20px;
    border: 2px dashed #d1d5db;
    border-radius: 12px;
    background: #f9fafb;
    margin-top: 16px;
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    align-items: flex-start;
    align-content: flex-start;
}

.techstack-grid.empty {
    justify-content: center;
    align-items: center;
    text-align: center;
}

.empty-message {
    color: #9ca3af;
    font-size: 14px;
    line-height: 1.5;
    text-align: center;
    width: 100%;
}

/* 선택된 기술스택 태그 */
.techstack-tag {
    display: inline-flex;
    align-items: center;
    background: #eff6ff;
    border: 1px solid #3b82f6;
    color: #1e40af;
    padding: 8px 12px;
    border-radius: 20px;
    font-size: 14px;
    gap: 8px;
    font-weight: 500;
}

.techstack-remove-btn {
    background: none;
    border: none;
    color: #1e40af;
    cursor: pointer;
    font-size: 16px;
    line-height: 1;
    padding: 0;
    width: 20px;
    height: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
}

.techstack-remove-btn:hover {
    background: rgba(30, 64, 175, 0.1);
}

/* 자동완성 제안 */
.techstack-suggestions {
    position: absolute;
    top: 100%;
    left: 0;
    right: 80px;
    background: white;
    border: 2px solid #e5e7eb;
    border-radius: 12px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    max-height: 200px;
    overflow-y: auto;
    z-index: 100;
    margin-top: 4px;
}

.suggestion-item {
    padding: 12px 16px;
    cursor: pointer;
    border-bottom: 1px solid #f3f4f6;
    transition: background-color 0.2s ease;
    font-size: 14px;
}

.suggestion-item:hover {
    background-color: #f3f4f6;
}

.suggestion-item:last-child {
    border-bottom: none;
}

/* 성향 선택 버튼들 */
.personality-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 8px;
    margin-top: 12px;
}

.personality-btn {
    padding: 12px 16px;
    border: 2px solid #e5e7eb;
    background: white;
    border-radius: 12px;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
    text-align: center;
    min-height: 48px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.personality-btn:hover {
    border-color: #3b82f6;
}

.personality-btn.selected {
    background: #3b82f6;
    border-color: #3b82f6;
    color: white;
}

/* 파일 업로드 스타일 */
.upload-container {
    border: 2px dashed #d1d5db;
    border-radius: 12px;
    padding: 20px;
    background-color: #f9fafb;
    text-align: center;
    transition: all 0.2s ease;
}

.upload-container.file-selected {
    border-color: #3b82f6;
    background-color: #eff6ff;
}

.upload-label {
    display: block;
    font-size: 14px;
    color: #6b7280;
    margin-bottom: 12px;
}

/* 업로드된 파일 정보 표시 */
.file-info {
    margin-top: 8px;
    padding: 8px 12px;
    background-color: #f0f9ff;
    border: 1px solid #0ea5e9;
    border-radius: 8px;
    font-size: 14px;
    color: #0369a1;
    display: none;
}

.file-info.show {
    display: block;
}

.file-name {
    font-weight: 600;
}

/* 체크박스 스타일 */
.checkbox-group {
    margin: 40px 0;
}

.checkbox-item {
    display: flex;
    align-items: center;
    margin-bottom: 16px;
    font-size: 14px;
    color: #333;
}

.checkbox-item input[type="checkbox"] {
    width: 20px;
    height: 20px;
    margin-right: 12px;
    accent-color: #3b82f6;
}

/* 버튼 스타일 */
.button-container {
    display: flex;
    gap: 12px;
    margin-top: 60px;
}

.btn-cancel {
    flex: 1;
    height: 56px;
    border: 2px solid #e5e7eb;
    border-radius: 12px;
    background-color: #ffffff;
    color: #6b7280;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
}

.btn-cancel:hover {
    border-color: #d1d5db;
    color: #374151;
}

.btn-primary {
    flex: 1;
    height: 56px;
    border: none;
    border-radius: 12px;
    background-color: #3b82f6;
    color: #ffffff;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
}

.btn-primary:hover {
    background-color: #2563eb;
}

.btn-primary:disabled {
    background-color: #e5e7eb;
    color: #9ca3af;
    cursor: not-allowed;
}

.help-text {
    font-size: 12px;
    color: #888;
    margin-top: 5px;
}

/* 섹션 관련 스타일 (기존 PostCreate에서 필요한 경우) */
.form-section {
    margin-bottom: 40px;
}

.section-title {
    font-size: 20px;
    font-weight: 600;
    color: #333;
    margin: 0 0 24px 0;
    display: flex;
    align-items: center;
    gap: 12px;
}

/* 반응형 디자인 */
@media (max-width: 480px) {
    .main-container {
        padding: 20px 16px;
    }
    
    .main-title {
        font-size: 24px;
    }
    
    .form-group {
        margin-bottom: 28px;
    }
    
    .form-row {
        flex-direction: column;
        gap: 0;
    }
    
    .personality-grid {
        grid-template-columns: repeat(2, 1fr);
    }
}
]]></style>

        <script lazy="false" type="text/javascript"><![CDATA[
scwin.onpageload = function() {
    console.log("=== PostCreate 페이지 로드 ===");
    
    // 권한 확인
    try {
        var userInfoStr = WebSquare.cookie.getCookie("userInfo");
        if (!userInfoStr) {
            $c.win.alert("로그인 정보가 없습니다. 다시 로그인해주세요.");
            $p.url("../user/Login.xml");
            return;
        }
        
        var userInfo = JSON.parse(userInfoStr);
        if (userInfo.role !== "COMPANY") {
            $c.win.alert("기업 사용자만 접근할 수 있습니다.");
            $p.url("../common/MainPage.xml");
            return;
        }
    } catch (e) {
        console.error("사용자 정보 확인 오류:", e);
        $c.win.alert("사용자 정보를 확인할 수 없습니다.");
        return;
    }
    
    // 기술스택 목록 조회
    scwin.loadTechStacks();
    
    // 선택된 성향 배열 초기화
    scwin.selectedPersonalities = [];
    scwin.maxPersonalities = 4;
    scwin.updatePersonalityCounter();
    
    // WebSquare DOM 로딩 완료 후 초기화
    setTimeout(function() {
        try {
            console.log("=== 페이지 초기화 완료 ===");
            console.log("기술스택 데이터리스트 개수:", dlt_techstack.getRowCount());
            
            // 초기 기술스택 태그 표시 (회색 박스 영역에)
            var container = document.querySelector('.techstack-grid');
            if (container) {
                container.innerHTML = '<div class="empty-message">아래 입력창에서 기술스택을 검색하고 선택하세요<br/>선택된 기술스택이 여기에 태그로 표시됩니다</div>';
                container.classList.add('empty');
                console.log("초기 빈 컨테이너 설정 완료");
            }
            
        } catch (error) {
            console.error("❌ 초기화 중 오류:", error);
        }
    }, 1000);
    
    // E*** 그룹 지원을 위한 이벤트 위임 설정
    setTimeout(function() {
        console.log("=== 이벤트 위임 설정 시작 ===");
        
        // 성향 섹션에 이벤트 위임 추가
        var personalitySection = document.querySelector('.personality-section');
        if (personalitySection) {
            personalitySection.addEventListener('click', function(e) {
                console.log("이벤트 위임으로 클릭 감지됨");
                
                // 성향 버튼 관련 요소인지 확인
                var target = e.target;
                var isPersonalityClick = false;
                
                // 클릭된 요소나 상위 요소가 성향 버튼인지 확인
                var currentElement = target;
                var maxDepth = 5;
                var depth = 0;
                
                while (currentElement && depth < maxDepth) {
                    if (currentElement.classList && (
                        currentElement.classList.contains('personality-btn') ||
                        currentElement.className.indexOf('personality') !== -1
                    )) {
                        isPersonalityClick = true;
                        console.log("성향 버튼 클릭으로 판단됨");
                        break;
                    }
                    
                    // 텍스트에서 성향 패턴 확인 (E 포함)
                    if (currentElement.textContent) {
                        var text = currentElement.textContent.trim();
                        if (/^[ABCDE][RIT][STF][DF]$/.test(text)) {
                            isPersonalityClick = true;
                            console.log("E*** 지원 성향 패턴으로 클릭 판단됨");
                            break;
                        }
                    }
                    
                    currentElement = currentElement.parentNode;
                    depth++;
                }
                
                if (isPersonalityClick) {
                    console.log("이벤트 위임에서 성향 버튼 클릭 처리");
                    // 기존 클릭 핸들러 호출
                    scwin.personality_btn_onclick(e);
                }
            });
            
            console.log("✅ E*** 그룹 지원 이벤트 위임 추가 완료");
        }
        
        console.log("=== 이벤트 위임 설정 완료 ===");
    }, 2000);
};

// 기술스택 목록 조회
scwin.loadTechStacks = function() {
    console.log("기술스택 목록 조회 시작");
    $p.executeSubmission("sbm_selectTechStackList");
};

scwin.sbm_selectTechStackList_submitdone = function(e) {
    console.log("=== 기술스택 목록 조회 완료 ===");
    console.log("응답 데이터:", e.responseJSON);
    
    try {
        // 서버에서 받은 기술스택 데이터로 전역 변수 설정
        scwin.allTechStacks = [];
        scwin.techStacksMap = {}; // 이름 -> ID 매핑
        
        // 서버 응답은 직접 배열로 온다 (List<TechStackVo>)
        var techStackList = e.responseJSON || [];
        console.log("서버에서 받은 기술스택 배열:", techStackList);
        console.log("받은 기술스택 개수:", techStackList.length);
        
        // 응답이 배열이 아닌 경우 (혹시나 해서)
        if (!Array.isArray(techStackList)) {
            console.log("응답이 배열이 아님, 다른 형태로 접근 시도");
            if (techStackList.techStackVoList) {
                techStackList = techStackList.techStackVoList;
            } else if (techStackList.elData && techStackList.elData.techStackVoList) {
                techStackList = techStackList.elData.techStackVoList;
            }
        }
        
        for (var i = 0; i < techStackList.length; i++) {
            var techStack = techStackList[i];
            var techStackId = techStack.techStackId;
            var techStackName = techStack.techStackName;
            
            if (techStackName) {
                scwin.allTechStacks.push(techStackName);
                scwin.techStacksMap[techStackName] = techStackId;
            }
        }
        
        console.log("처리된 기술스택 목록:", scwin.allTechStacks);
        console.log("기술스택 매핑:", scwin.techStacksMap);
        
        // 기술스택 카드 영역 초기화 (비워둠)
        scwin.createTechStackCards();
        
    } catch (error) {
        console.error("기술스택 목록 처리 중 오류:", error);
        alert("기술스택 목록을 불러오는 중 오류가 발생했습니다.");
    }
};

// 기술스택 카드 영역 초기화 (비워둠)
scwin.createTechStackCards = function() {
    console.log("=== 기술스택 카드 영역 초기화 ===");
    
    var techstackGrid = document.querySelector('.techstack-grid');
    if (!techstackGrid) {
        console.error("기술스택 그리드를 찾을 수 없습니다");
        return;
    }
    
    // 카드 영역을 완전히 비워둠 - 선택된 기술스택만 아래 태그 영역에 표시
    techstackGrid.innerHTML = '';
    
    // 안내 메시지 추가
    var helpText = document.createElement('div');
    helpText.className = 'empty-techstack-help';
    helpText.style.cssText = 'padding: 40px 20px; text-align: center; color: #64748b; font-size: 14px; background: #f8fafc; border: 2px dashed #e2e8f0; border-radius: 8px;';
    helpText.innerHTML = '아래 입력창에서 기술스택을 검색하고 선택하세요<br/>선택된 기술스택이 여기에 태그로 표시됩니다';
    
    techstackGrid.appendChild(helpText);
    
    console.log("기술스택 카드 영역 초기화 완료 - 선택된 것만 태그로 표시됩니다");
};

// ===============================================
// 기존 카드 클릭 관련 함수들은 더 이상 사용하지 않음
// 선택된 기술스택은 자동완성을 통해서만 추가되고
// 아래 태그 영역에 표시되며 X 버튼으로 제거 가능
// ===============================================

// 기술스택 입력 이벤트
scwin.input_techstack_oninput = function(e) {
    var inputValue = input_techstack.getValue();
    if (inputValue && inputValue.length > 0) {
        scwin.showTechStackSuggestions(inputValue);
    } else {
        // 빈 값일 때는 인기 기술스택 추천 표시
        scwin.showPopularTechStacks();
    }
};

scwin.input_techstack_onkeypress = function(e) {
    if (e.keyCode === 13) { // Enter 키
        e.preventDefault();
        scwin.addTechStackFromInput();
    }
};

// 입력창 포커스 시 인기 기술스택 표시
scwin.input_techstack_onfocus = function(e) {
    var inputValue = input_techstack.getValue();
    if (!inputValue || inputValue.trim() === '') {
        scwin.showPopularTechStacks();
    } else {
        scwin.showTechStackSuggestions(inputValue);
    }
};

// 입력창 포커스 아웃 시 추천 목록 숨김 (약간의 지연 추가)
scwin.input_techstack_onblur = function(e) {
    setTimeout(function() {
        scwin.hideTechStackSuggestions();
    }, 200);
};

// 인기 기술스택 표시
scwin.showPopularTechStacks = function() {
    console.log("=== 인기 기술스택 표시 ===");
    
    if (!scwin.allTechStacks || scwin.allTechStacks.length === 0) {
        console.log("서버 기술스택 데이터가 아직 로드되지 않았습니다");
        return;
    }
    
    var suggestionsContainer = document.getElementById('techstack-suggestions');
    if (!suggestionsContainer) {
        console.error("추천 목록 컨테이너를 찾을 수 없습니다");
        return;
    }
    
    // 인기 기술스택들
    var popularTechStacks = ["Java", "JavaScript", "Python", "React", "Spring Boot", "Node.js", 
                            "MySQL", "MongoDB", "Docker", "Kubernetes", "Vue.js", "Angular"];
    
    // 서버에 있는 인기 기술스택들만 필터링
    var availablePopularStacks = [];
    for (var i = 0; i < popularTechStacks.length; i++) {
        if (scwin.allTechStacks.indexOf(popularTechStacks[i]) !== -1) {
            availablePopularStacks.push(popularTechStacks[i]);
        }
    }
    
    // 최대 8개까지만 표시
    if (availablePopularStacks.length > 8) {
        availablePopularStacks = availablePopularStacks.slice(0, 8);
    }
    
    scwin.displaySuggestions(availablePopularStacks, "인기 기술스택");
};

// 자동완성 추천 목록 표시
scwin.showTechStackSuggestions = function(inputValue) {
    console.log("=== 추천 목록 표시 시작 ===");
    console.log("입력값:", inputValue);
    
    if (!scwin.allTechStacks || scwin.allTechStacks.length === 0) {
        console.log("서버 기술스택 데이터가 아직 로드되지 않았습니다");
        return;
    }
    
    var suggestionsContainer = document.getElementById('techstack-suggestions');
    if (!suggestionsContainer) {
        console.error("추천 목록 컨테이너를 찾을 수 없습니다");
        return;
    }
    
    var input = inputValue ? inputValue.toLowerCase().trim() : '';
    
    if (input === '') {
        scwin.showPopularTechStacks();
        return;
    }
    
    // 이미 선택된 기술스택 목록
    var selectedTechStacks = [];
    for (var i = 0; i < dlt_techstack.getRowCount(); i++) {
        var techstack = dlt_techstack.getCellData(i, "techstack");
        if (techstack) {
            selectedTechStacks.push(techstack);
        }
    }
    
    var suggestions = [];
    
    // 서버에서 받은 기술스택들에서 검색
    for (var i = 0; i < scwin.allTechStacks.length; i++) {
        var techStack = scwin.allTechStacks[i];
        
        // 이미 선택된 기술스택은 제외
        if (selectedTechStacks.indexOf(techStack) !== -1) continue;
        
        // 입력값과 매칭되는지 확인
        if (techStack.toLowerCase().includes(input)) {
            suggestions.push({
                name: techStack,
                matchIndex: techStack.toLowerCase().indexOf(input)
            });
        }
    }
    
    // 매칭 순서로 정렬 (앞부분 매칭이 우선)
    suggestions.sort(function(a, b) {
        if (a.matchIndex !== b.matchIndex) {
            return a.matchIndex - b.matchIndex;
        }
        return a.name.localeCompare(b.name);
    });
    
    // 최대 8개까지만 표시
    suggestions = suggestions.slice(0, 8);
    
    if (suggestions.length === 0) {
        scwin.hideTechStackSuggestions();
        return;
    }
    
    // 공통 함수로 추천 목록 표시
    var techStackNames = [];
    for (var i = 0; i < suggestions.length; i++) {
        techStackNames.push(suggestions[i].name);
    }
    scwin.displaySuggestions(techStackNames, "검색 결과", input)
};

// 공통 추천 목록 표시 함수
scwin.displaySuggestions = function(techStacks, title, highlightText) {
    console.log("=== 추천 목록 표시 ===");
    console.log("제목:", title);
    console.log("기술스택들:", techStacks);
    
    var suggestionsContainer = document.getElementById('techstack-suggestions');
    if (!suggestionsContainer) {
        console.error("추천 목록 컨테이너를 찾을 수 없습니다");
        return;
    }
    
    if (!techStacks || techStacks.length === 0) {
        scwin.hideTechStackSuggestions();
        return;
    }
    
    // HTML 생성
    var html = '';
    
    // 제목 추가
    if (title) {
        html += '<div style="padding: 8px 16px; background: #f8fafc; border-bottom: 1px solid #e2e8f0; font-weight: 600; font-size: 12px; color: #64748b;">' + title + '</div>';
    }
    
    // 기술스택 항목들 생성
    for (var i = 0; i < techStacks.length; i++) {
        var techStack = techStacks[i];
        var displayText = techStack;
        
        // 하이라이트 처리 (검색어가 있는 경우)
        if (highlightText && highlightText.trim() !== '') {
            displayText = scwin.highlightMatch(techStack, highlightText);
        }
        
        var escapedName = techStack.replace(/'/g, "&#39;").replace(/"/g, "&quot;");
        
        html += '<div class="suggestion-item" ' +
                'data-techstack="' + escapedName + '" ' +
                'style="cursor: pointer;">' +
                '<span class="suggestion-match">' + displayText + '</span>' +
                '</div>';
    }
    
    suggestionsContainer.innerHTML = html;
    suggestionsContainer.style.display = 'block';
    
    // 이벤트 위임 설정 (한 번만)
    if (!suggestionsContainer._eventSet) {
        console.log("추천 목록 이벤트 리스너 설정");
        
        suggestionsContainer.addEventListener('mousedown', function(e) {
            e.preventDefault();
            var target = e.target.closest('.suggestion-item');
            if (target) {
                var techStack = target.getAttribute('data-techstack');
                if (techStack) {
                    scwin.selectSuggestion(techStack);
                }
            }
            return false;
        });
        
        suggestionsContainer.addEventListener('click', function(e) {
            e.preventDefault();
            var target = e.target.closest('.suggestion-item');
            if (target) {
                var techStack = target.getAttribute('data-techstack');
                if (techStack) {
                    scwin.selectSuggestion(techStack);
                }
            }
            return false;
        });
        
        suggestionsContainer._eventSet = true;
    }
    
    console.log("추천 목록 표시 완료:", techStacks.length + "개");
};

// 추천 목록 숨기기
scwin.hideTechStackSuggestions = function() {
    var suggestionsContainer = document.getElementById('techstack-suggestions');
    if (suggestionsContainer) {
        suggestionsContainer.style.display = 'none';
        console.log("추천 목록 숨김");
    }
};

// 텍스트에서 매칭 부분 하이라이트
scwin.highlightMatch = function(text, match) {
    var index = text.toLowerCase().indexOf(match.toLowerCase());
    if (index === -1) return text;
    
    return text.substring(0, index) + 
           '<strong>' + text.substring(index, index + match.length) + '</strong>' + 
           text.substring(index + match.length);
};

// 추천 항목 선택
scwin.selectSuggestion = function(techStack) {
    console.log("=== 추천 목록에서 선택됨 ===");
    console.log("선택된 기술스택:", techStack);
    
    // 추천 목록 숨기기
    scwin.hideTechStackSuggestions();
    
    // 이미 존재하는지 확인
    var selectedTechStacks = [];
    for (var i = 0; i < dlt_techstack.getRowCount(); i++) {
        var tech = dlt_techstack.getCellData(i, "techstack");
        if (tech) {
            selectedTechStacks.push(tech);
        }
    }
    
    console.log("현재 선택된 기술스택들:", selectedTechStacks);
    console.log("DataList 행 개수:", dlt_techstack.getRowCount());
    
    if (selectedTechStacks.indexOf(techStack) === -1) {
        // 새로 추가
        console.log("새 기술스택 추가 시도:", techStack);
        
        var newRowIndex = dlt_techstack.insertRow();
        console.log("새 행 인덱스:", newRowIndex);
        
        dlt_techstack.setCellData(newRowIndex, "techstack", techStack);
        console.log("데이터 설정 완료");
        
        // 데이터 확인
        var addedData = dlt_techstack.getCellData(newRowIndex, "techstack");
        console.log("추가된 데이터 확인:", addedData);
        console.log("DataList 전체 행 개수:", dlt_techstack.getRowCount());
        
        // 수동 DOM 업데이트
        console.log("수동 DOM 업데이트 시작");
        scwin.manualUpdateTechStackTags();
        
        // 입력 필드 초기화
        input_techstack.setValue("");
        
        console.log("✅ 자동완성 선택 및 추가 완료:", techStack);
        
        // 수동 DOM 업데이트
        setTimeout(function() {
            console.log("=== 자동완성 추가 후 DOM 업데이트 ===");
            scwin.manualUpdateTechStackTags();
            
            // 최종 상태 로그
            console.log("총 기술스택 개수:", dlt_techstack.getRowCount());
            for (var i = 0; i < dlt_techstack.getRowCount(); i++) {
                var tech = dlt_techstack.getCellData(i, "techstack");
                console.log("기술스택 " + i + ":", tech);
            }
        }, 300);
        
    } else {
        console.log("이미 존재하는 기술스택:", techStack);
        $c.win.alert("이미 선택된 기술스택입니다.");
        // 입력 필드 초기화
        input_techstack.setValue("");
    }
};

// 기술스택 추가
scwin.addTechStackFromInput = function() {
    var inputValue = input_techstack.getValue();
    if (!inputValue || inputValue.trim() === "") {
        $c.win.alert("기술스택을 입력해주세요.");
        return;
    }
    
    // 기술스택 정규화
    var normalizedTechStack = scwin.normalizeTechStack(inputValue);
    if (!normalizedTechStack) {
        $c.win.alert("지원하지 않는 기술스택입니다.");
        return;
    }
    
    // 중복 확인
    for (var i = 0; i < dlt_techstack.getRowCount(); i++) {
        if (dlt_techstack.getCellData(i, "techstack") === normalizedTechStack) {
            $c.win.alert("이미 선택된 기술스택입니다.");
            return;
        }
    }
    
    // 기술스택 추가
    var newIndex = dlt_techstack.insertRow();
    dlt_techstack.setCellData(newIndex, "techstack", normalizedTechStack);
    
    // 수동 DOM 업데이트
    console.log("수동 DOM 업데이트 실행");
    scwin.manualUpdateTechStackTags();
    
    // 입력창 초기화
    input_techstack.setValue("");
    scwin.hideTechStackSuggestions();
    
    console.log("기술스택 추가:", normalizedTechStack);
};

// 기술스택 정규화
scwin.normalizeTechStack = function(input) {
    if (!input || !scwin.allTechStacks) return null;
    
    var inputLower = input.toLowerCase().trim();
    
    // 정확한 매칭
    for (var i = 0; i < scwin.allTechStacks.length; i++) {
        if (scwin.allTechStacks[i].toLowerCase() === inputLower) {
            return scwin.allTechStacks[i];
        }
    }
    
    // 부분 매칭
    for (var i = 0; i < scwin.allTechStacks.length; i++) {
        if (scwin.allTechStacks[i].toLowerCase().includes(inputLower)) {
            return scwin.allTechStacks[i];
        }
    }
    
    return null;
};

// Generator 대안: 수동 DOM 업데이트 함수
scwin.manualUpdateTechStackTags = function() {
    console.log("=== 수동 DOM 업데이트 시작 ===");
    
    // 회색 박스 영역(techstack-grid)을 태그 표시용으로 사용
    var container = document.querySelector('.techstack-grid');
    if (!container) {
        console.error("기술스택 그리드 컨테이너를 찾을 수 없습니다. 다시 시도합니다.");
        // WebSquare DOM 로딩 지연 대응
        setTimeout(function() {
            scwin.manualUpdateTechStackTags();
        }, 500);
        return;
    }
    
    console.log("컨테이너 찾음:", container);
    console.log("컨테이너 클래스:", container.className);
    console.log("컨테이너 위치:", container.getBoundingClientRect());
    
    // 기존 태그들 모두 제거
    container.innerHTML = '';
    
    // DataList에서 현재 기술스택들 가져와서 HTML 문자열로 생성 (다른 페이지 패턴)
    var tagsHtml = '';
    
    for (var i = 0; i < dlt_techstack.getRowCount(); i++) {
        var techStack = dlt_techstack.getCellData(i, "techstack");
        if (techStack && techStack.trim() !== '') {
            tagsHtml += '<div class="techstack-tag">' +
                           '<span class="techstack-text">' + techStack + '</span>' +
                           '<button class="techstack-remove-btn" type="button" onclick="scwin.removeTechStackByName(\'' + techStack + '\')">×</button>' +
                       '</div>';
        }
    }
    
    // 한 번에 innerHTML로 설정 및 클래스 상태 변경
    if (tagsHtml === '') {
        container.innerHTML = '<div class="empty-message">◆◆◆◆◆ 아래 입력창에서 기술스택을 검색하고 선택하세요<br/>선택된 기술스택이 여기에 태그로 표시됩니다</div>';
        container.classList.add('empty');
    } else {
        container.innerHTML = tagsHtml;
        container.classList.remove('empty');
    }
    
    console.log("수동 DOM 업데이트 완료:", dlt_techstack.getRowCount() + "개");
};

// 기술스택 이름으로 제거 (더 안전한 방식)
scwin.removeTechStackByName = function(techStackName) {
    console.log("=== 기술스택 이름으로 제거 시작 ===");
    console.log("제거할 기술스택:", techStackName);
    
    try {
        // 해당 기술스택이 있는 행 찾기
        var foundIndex = -1;
        for (var i = 0; i < dlt_techstack.getRowCount(); i++) {
            var tech = dlt_techstack.getCellData(i, "techstack");
            if (tech === techStackName) {
                foundIndex = i;
                break;
            }
        }
        
        if (foundIndex >= 0) {
            // 데이터리스트에서 해당 행 삭제
            dlt_techstack.removeRow(foundIndex);
            console.log("기술스택 제거 완료:", techStackName);
            
            // DOM 업데이트
            scwin.manualUpdateTechStackTags();
        } else {
            console.error("제거할 기술스택을 찾을 수 없습니다:", techStackName);
        }
        
    } catch (error) {
        console.error("기술스택 제거 중 오류:", error);
    }
    
    console.log("=== 기술스택 제거 완료 ===");
};

// CreatePosting.xml과 동일한 기술스택 제거 함수 (호환성용)
scwin.removeTechStackByIndex = function(rowIndex) {
    console.log("=== 기술스택 제거 시작 ===");
    console.log("제거할 행 인덱스:", rowIndex);
    
    try {
        // 현재 데이터 확인
        console.log("제거 전 기술스택 개수:", dlt_techstack.getRowCount());
        
        if (rowIndex >= 0 && rowIndex < dlt_techstack.getRowCount()) {
            var techstack = dlt_techstack.getCellData(rowIndex, "techstack");
            console.log("제거할 기술스택:", techstack);
            
            // 데이터리스트에서 해당 행 삭제
            dlt_techstack.removeRow(rowIndex);
            
            console.log("제거 후 기술스택 개수:", dlt_techstack.getRowCount());
            
            // 수동 DOM 업데이트
            console.log("수동 DOM 업데이트 실행 (제거)");
            scwin.manualUpdateTechStackTags();
            
            console.log("기술스택 제거 완료:", techstack);
        } else {
            console.error("잘못된 행 인덱스:", rowIndex);
        }
        
    } catch (error) {
        console.error("기술스택 제거 중 오류:", error);
    }
    
    console.log("=== 기술스택 제거 완료 ===");
};

// CreatePosting.xml과 동일한 성향 카운터 업데이트
scwin.updatePersonalityCounter = function() {
    var counter = document.querySelector('.personality-counter');
    if (!counter) {
        // 카운터 엘리먼트가 없으면 생성
        var section = document.querySelector('.personality-section');
        if (section) {
            counter = document.createElement('div');
            counter.className = 'personality-counter';
            section.style.position = 'relative';
            section.appendChild(counter);
        }
    }
    
    if (counter) {
        var selectedCount = scwin.selectedPersonalities.length;
        counter.textContent = selectedCount + '/' + scwin.maxPersonalities;
        
        console.log("성향 카운터 업데이트:", selectedCount + '/' + scwin.maxPersonalities);
        
        // 카운터 색상 변경
        if (selectedCount >= scwin.maxPersonalities) {
            counter.style.background = 'linear-gradient(135deg, #e53e3e, #c53030)';
        } else {
            counter.style.background = 'linear-gradient(135deg, #ed8936, #dd6b20)';
        }
        
        // 강제로 보이게 하기
        counter.style.display = 'block';
        counter.style.visibility = 'visible';
    }
};

// CreatePosting.xml과 동일한 성향 버튼 상태 업데이트
scwin.updatePersonalityButtons = function() {
    var selectedCount = scwin.selectedPersonalities.length;
    
    console.log("=== 성향 버튼 상태 업데이트 시작 ===");
    console.log("선택된 개수:", selectedCount);
    console.log("선택된 성향들:", scwin.selectedPersonalities);
    
    // 모든 가능한 선택자로 성향 버튼 찾기
    var personalitySelectors = [
        '.personality-btn',
        '[class*="personality"]',
        '[id*="personality"]',
        'xf\\:trigger[class*="personality"]',
        'input[class*="personality"]'
    ];
    
    var allButtons = [];
    
    // 각 선택자로 요소 찾기
    for (var s = 0; s < personalitySelectors.length; s++) {
        try {
            var foundElements = document.querySelectorAll(personalitySelectors[s]);
            console.log("선택자 '" + personalitySelectors[s] + "'로 찾은 버튼:", foundElements.length);
            
            for (var e = 0; e < foundElements.length; e++) {
                var element = foundElements[e];
                // 중복 제거
                var isDuplicate = false;
                for (var b = 0; b < allButtons.length; b++) {
                    if (allButtons[b] === element) {
                        isDuplicate = true;
                        break;
                    }
                }
                
                if (!isDuplicate) {
                    allButtons.push(element);
                }
            }
        } catch (error) {
            console.log("선택자 '" + personalitySelectors[s] + "' 사용 중 오류:", error);
        }
    }
    
    console.log("총 찾은 버튼 개수:", allButtons.length);
    
    // 각 버튼의 성향 추출 및 상태 업데이트
    var updatedButtons = 0;
    for (var i = 0; i < allButtons.length; i++) {
        var btn = allButtons[i];
        var personality = "";
        
        try {
            // 방법 1: label 요소의 텍스트
            var label = btn.querySelector('label');
            if (label && label.textContent) {
                personality = label.textContent.trim();
            }
            
            // 방법 2: ID에서 추출
            if (!personality && btn.id) {
                if (btn.id.indexOf('mf_personality_') === 0) {
                    personality = btn.id.replace('mf_personality_', '');
                } else if (btn.id.indexOf('personality_') === 0) {
                    personality = btn.id.replace('personality_', '');
                }
            }
            
            // 방법 3: 텍스트 내용에서 성향 패턴 추출
            if (!personality && btn.textContent) {
                var textContent = btn.textContent.toUpperCase();
                var personalityPattern = /([ABCDE][RIT][STF][DF])/g;
                var matches = textContent.match(personalityPattern);
                
                if (matches && matches.length > 0) {
                    personality = matches[0];
                }
            }
            
            console.log("버튼 " + i + " - 성향:", personality);
            
            if (personality) {
                // 현재 이 성향이 선택되어 있는지 확인
                var isSelectedInArray = scwin.selectedPersonalities.indexOf(personality) !== -1;
                
                console.log("성향 " + personality + " 선택됨:", isSelectedInArray);
                
                // UI 상태 동기화
                if (isSelectedInArray) {
                    btn.classList.add('selected');
                    console.log("✅ 버튼 선택 상태로 변경:", personality);
                } else {
                    btn.classList.remove('selected');
                    console.log("❌ 버튼 선택 해제 상태로 변경:", personality);
                }
                
                // 비활성화 처리
                if (!isSelectedInArray && selectedCount >= scwin.maxPersonalities) {
                    btn.classList.add('disabled');
                    console.log("버튼 비활성화:", personality);
                } else {
                    btn.classList.remove('disabled');
                    console.log("✅ 버튼 활성화:", personality);
                }
                
                updatedButtons++;
            } else {
                console.log("⚠️ 성향을 추출하지 못한 버튼");
            }
            
        } catch (error) {
            console.error("버튼 처리 중 오류:", error, btn);
        }
    }
    
    console.log("상태 업데이트된 버튼 개수:", updatedButtons);
    console.log("=== 성향 버튼 상태 업데이트 완료 ===");
};

// CreatePosting.xml과 동일한 성향 버튼 클릭 처리 (완전 복사)
scwin.personality_btn_onclick = function (e) {
    console.log("=== 성향 버튼 클릭 이벤트 시작 ===");
    
    // 이벤트 전파 방지
    if (e) {
        e.preventDefault();
        e.stopPropagation();
    }
    
    // 먼저 4개 제한 확인 (성향 인식 전에)
    if (scwin.selectedPersonalities.length >= scwin.maxPersonalities) {
        // 선택된 성향이 이미 4개인 경우, 클릭한 버튼이 이미 선택된 것인지만 확인
        var clickedElement = e.target || e.srcElement;
        var isClickedSelected = false;
        
        // 클릭된 버튼이 선택된 상태인지 빠르게 확인
        var currentElement = clickedElement;
        var depth = 0;
        while (currentElement && depth < 5) {
            if (currentElement.classList && currentElement.classList.contains('selected')) {
                isClickedSelected = true;
                break;
            }
            currentElement = currentElement.parentNode;
            depth++;
        }
        
        // 선택되지 않은 버튼을 클릭한 경우 즉시 차단
        if (!isClickedSelected) {
            $c.win.alert("최대 " + scwin.maxPersonalities + "개까지만 선택 가능합니다.");
            return;
        }
    }
    
    var personality = "";
    var btn = null;
    var eventSource = e.target || e.srcElement;
    
    console.log("=== 이벤트 소스 디버깅 ===");
    console.log("태그명:", eventSource.tagName);
    console.log("ID:", eventSource.id);
    console.log("클래스:", eventSource.className);
    console.log("텍스트 내용:", eventSource.textContent);
    
    // 모든 가능한 방법으로 성향과 버튼 찾기
    var methods = [
        // 방법 1: 직접 라벨에서 성향 텍스트 추출
        function() {
            try {
                var label = eventSource.querySelector('label');
                if (label && label.textContent) {
                    var text = label.textContent.trim();
                    if (/^[ABCDE][RIT][STF][DF]$/.test(text)) {
                        personality = text;
                        btn = eventSource;
                        return true;
                    }
                }
            } catch (error) {
                console.log("방법1 오류:", error);
            }
            return false;
        },
        
        // 방법 2: 이벤트 소스가 라벨인 경우
        function() {
            try {
                if (eventSource.tagName === 'LABEL') {
                    var text = eventSource.textContent.trim();
                    if (/^[ABCDE][RIT][STF][DF]$/.test(text)) {
                        personality = text;
                        btn = eventSource.parentNode;
                        return true;
                    }
                }
            } catch (error) {
                console.log("방법2 오류:", error);
            }
            return false;
        },
        
        // 방법 3: 광범위한 상위 요소 탐색
        function() {
            try {
                var currentElement = eventSource;
                var maxDepth = 15;
                var depth = 0;
                
                while (currentElement && depth < maxDepth) {
                    console.log("탐색 레벨 " + depth + ":", currentElement.tagName, currentElement.id, currentElement.className);
                    
                    // 현재 요소에서 라벨 찾기
                    var labels = currentElement.querySelectorAll('label');
                    for (var i = 0; i < labels.length; i++) {
                        var labelText = labels[i].textContent.trim();
                        if (/^[ABCDE][RIT][STF][DF]$/.test(labelText)) {
                            personality = labelText;
                            btn = currentElement;
                            console.log("상위 탐색에서 발견 - 레벨:", depth, "성향:", personality);
                            return true;
                        }
                    }
                    
                    // 현재 요소가 성향 버튼인지 확인
                    if (currentElement.classList && (
                        currentElement.classList.contains('personality-btn') ||
                        currentElement.className.indexOf('personality') !== -1
                    )) {
                        var selfLabel = currentElement.querySelector('label');
                        if (selfLabel && selfLabel.textContent) {
                            var selfText = selfLabel.textContent.trim();
                            if (/^[ABCDE][RIT][STF][DF]$/.test(selfText)) {
                                personality = selfText;
                                btn = currentElement;
                                console.log("성향 버튼에서 발견:", personality);
                                return true;
                            }
                        }
                    }
                    
                    // ID에서 성향 추출 시도
                    if (currentElement.id) {
                        var personalityFromId = "";
                        if (currentElement.id.indexOf('personality_') !== -1) {
                            personalityFromId = currentElement.id.replace(/.*personality_/, '');
                        } else if (currentElement.id.indexOf('mf_personality_') !== -1) {
                            personalityFromId = currentElement.id.replace(/.*mf_personality_/, '');
                        }
                        
                        if (personalityFromId && /^[ABCDE][RIT][STF][DF]$/.test(personalityFromId)) {
                            personality = personalityFromId;
                            btn = currentElement;
                            console.log("ID에서 발견:", personality);
                            return true;
                        }
                    }
                    
                    currentElement = currentElement.parentNode;
                    depth++;
                }
            } catch (error) {
                console.log("방법3 오류:", error);
            }
            return false;
        }
    ];
    
    // 각 방법을 차례로 시도
    var methodFound = false;
    for (var m = 0; m < methods.length; m++) {
        console.log("방법 " + (m + 1) + " 시도 중...");
        if (methods[m]()) {
            console.log("✅ 방법 " + (m + 1) + " 성공!");
            methodFound = true;
            break;
        }
    }
    
    console.log("=== 최종 결과 ===");
    console.log("추출된 성향:", personality);
    console.log("찾은 버튼:", btn);
    console.log("방법 성공 여부:", methodFound);
    
    // 성향을 찾지 못한 경우
    if (!personality || personality === "") {
        console.error("❌ 모든 방법으로 성향을 찾지 못했습니다");
        return;
    }
    
    if (!btn) {
        console.error("❌ 버튼 요소를 찾을 수 없습니다");
        return;
    }
    
    console.log("✅ 성향 인식 성공:", personality);
    
    // 현재 선택 상태 확인 - 배열에서 직접 확인 (가장 확실한 방법)
    var isCurrentlySelected = scwin.selectedPersonalities.indexOf(personality) !== -1;
    console.log("현재 선택 상태 (배열):", isCurrentlySelected);
    console.log("현재 선택된 성향들:", scwin.selectedPersonalities);
    
    if (isCurrentlySelected) {
        // 선택 해제
        console.log("=== 선택 해제 시작 ===");
        
        // 1. 배열에서 제거
        var arrayIndex = scwin.selectedPersonalities.indexOf(personality);
        if (arrayIndex > -1) {
            scwin.selectedPersonalities.splice(arrayIndex, 1);
            console.log("배열에서 제거 완료");
        }
        
        // 2. 데이터리스트에서 제거
        for (var i = dlt_personalities.getRowCount() - 1; i >= 0; i--) {
            var dataPersonality = dlt_personalities.getCellData(i, "personality");
            if (dataPersonality === personality) {
                dlt_personalities.removeRow(i);
                console.log("데이터리스트에서 제거 완료");
            }
        }
        
        // 3. UI 클래스 제거
        btn.classList.remove('selected');
        console.log("UI 클래스 제거 완료");
        
        console.log("✅ 성향 선택 해제:", personality);
    } else {
        // 선택 추가 - 4개 제한 확인
        if (scwin.selectedPersonalities.length >= scwin.maxPersonalities) {
            $c.win.alert("최대 " + scwin.maxPersonalities + "개까지만 선택 가능합니다.");
            return;
        }
        
        // 1. 배열에 추가
        scwin.selectedPersonalities.push(personality);
        // 2. 데이터리스트에 추가
        var newRowIndex = dlt_personalities.insertRow();
        dlt_personalities.setCellData(newRowIndex, "personality", personality);
        
        // 3. UI 클래스 추가
        btn.classList.add('selected');
    }
    
    // 상태 업데이트
    scwin.updatePersonalityCounter();
    scwin.updatePersonalityButtons();
    
    console.log("=== 업데이트 후 상태 ===");
    console.log("선택된 성향들:", scwin.selectedPersonalities);
    console.log("데이터리스트 개수:", dlt_personalities.getRowCount());
    console.log("=== 성향 버튼 클릭 이벤트 완료 ===");
};

// 공고 이미지 파일 선택 이벤트 (CreateCompany 방식 완전 적용)
scwin.job_image_upload_onInputValueChange = function (fileName) {
    console.log("=== 공고 이미지 파일 선택 ===", fileName);
    
    if (fileName) {
        document.getElementById("job_image_file_info").style.display = "block";
        document.getElementById("job_image_file_name").textContent = fileName;
        document.getElementById("job_image_upload_container").classList.add("file-selected");
    } else {
        document.getElementById("job_image_file_info").style.display = "none";
        document.getElementById("job_image_upload_container").classList.remove("file-selected");
    }
};

// 파일 업로드 완료 이벤트 (CreateCompany 방식)
scwin.job_image_upload_ondone = function() {
    console.log("=== 공고 이미지 업로드 완료 ===");
};

// 파일 업로드 실행 함수 (CreateCompany 방식 완전 동일하게 적용)
scwin.uploadJobImage = function() {
    console.log("=== 공고 이미지 업로드 실행 ===");
    
    var hasJobImage = job_image_upload.getValue();
    console.log("선택된 공고 이미지:", hasJobImage);

    // 공고 이미지 업로드 (CreateCompany 로고 업로드와 완전히 동일)
    if (hasJobImage) {
        console.log("공고 이미지 업로드 시작...");
        job_image_upload.submit();
        
        // 파일명 추출 (CreateCompany와 정확히 동일한 방식)
        var fullPath = job_image_upload.getValue();
        var fileName = fullPath.split('\\').pop(); // Extract filename
        
        console.log("전체 경로:", fullPath);
        console.log("추출된 파일명:", fileName);
        
        // 데이터 모델에 파일명 저장 (CreateCompany와 동일)
        dmp_postVo.set("jobImageFileName", fileName);
        
        console.log("✅ 공고 이미지 파일명 설정 완료:", fileName);
        console.log("데이터맵에 설정된 값:", dmp_postVo.get("jobImageFileName"));
    } else {
        console.log("선택된 공고 이미지가 없습니다.");
    }
};

// 취소 버튼
scwin.btn_cancel_onclick = function() {
    if (confirm("입력한 내용이 모두 사라집니다. 정말 취소하시겠습니까?")) {
        $p.url("../corporate/RecruitmentDashboard.xml");
    }
};

// 공고 등록 버튼
scwin.btn_create_post_onclick = function() {
    console.log("=== 공고 등록 시작 ===");
    
    // 필수 필드 검증
    var errors = [];
    
    if (!dmp_postVo.get("title") || dmp_postVo.get("title").trim() === "") {
        errors.push("공고 제목을 입력해주세요.");
    }
    
    if (!dmp_postVo.get("location") || dmp_postVo.get("location").trim() === "") {
        errors.push("근무 지역을 선택해주세요.");
    }
    
    if (!dmp_postVo.get("workType") || dmp_postVo.get("workType").trim() === "") {
        errors.push("근무 형태를 선택해주세요.");
    }
    
    if (dlt_techstack.getRowCount() === 0) {
        errors.push("최소 1개 이상의 기술스택을 선택해주세요.");
    }
    
    if (dlt_personalities.getRowCount() === 0) {
        errors.push("최소 1개 이상의 선호 성향을 선택해주세요.");
    }
    
    if (!dmp_postVo.get("description") || dmp_postVo.get("description").trim() === "") {
        errors.push("상세 설명을 입력해주세요.");
    }
    
    if (errors.length > 0) {
        $c.win.alert("다음 항목들을 확인해주세요:\n\n" + errors.join("\n"));
        return;
    }
    
    // 확인 대화상자
    if (!confirm("공고를 등록하시겠습니까?")) {
        return;
    }
    
    // 회사 ID 설정
    var companyId = null;
    try {
        var userInfoStr = WebSquare.cookie.getCookie("userInfo");
        if (!userInfoStr) {
            throw new Error("userInfo 쿠키가 없습니다.");
        }
        
        var userInfo = JSON.parse(userInfoStr);
        console.log("쿠키에서 가져온 사용자 정보:", userInfo);
        
        if (userInfo && userInfo.companyId) {
            companyId = userInfo.companyId;
            console.log("✅ 쿠키에서 companyId 추출 성공:", companyId);
        } else {
            throw new Error("쿠키에 companyId가 없습니다: " + JSON.stringify(userInfo));
        }
    } catch (e) {
        console.error("❌ 회사 ID 가져오기 실패:", e);
        $c.win.alert("회사 정보를 확인할 수 없습니다.\n다시 로그인해주세요.\n\n오류: " + e.message);
        $p.url("../user/Login.xml");
        return;
    }
    
    // 날짜 설정
    var currentDate = new Date();
    var dateString = currentDate.getFullYear() + '-' + 
                     String(currentDate.getMonth() + 1).padStart(2, '0') + '-' + 
                     String(currentDate.getDate()).padStart(2, '0') + ' ' +
                     String(currentDate.getHours()).padStart(2, '0') + ':' +
                     String(currentDate.getMinutes()).padStart(2, '0') + ':' +
                     String(currentDate.getSeconds()).padStart(2, '0');
    
    var expiryDate = new Date(currentDate);
    expiryDate.setDate(expiryDate.getDate() + 30);
    var expiryString = expiryDate.getFullYear() + '-' + 
                      String(expiryDate.getMonth() + 1).padStart(2, '0') + '-' + 
                      String(expiryDate.getDate()).padStart(2, '0') + ' ' +
                      String(expiryDate.getHours()).padStart(2, '0') + ':' +
                      String(expiryDate.getMinutes()).padStart(2, '0') + ':' +
                      String(expiryDate.getSeconds()).padStart(2, '0');
    
    // 기술스택 JSON 생성
    var techStackArray = [];
    for (var i = 0; i < dlt_techstack.getRowCount(); i++) {
        var techstack = dlt_techstack.getCellData(i, "techstack");
        if (techstack) {
            techStackArray.push(techstack);
        }
    }
    
    // 성향 JSON 생성
    var personalityArray = [];
    for (var i = 0; i < dlt_personalities.getRowCount(); i++) {
        var personality = dlt_personalities.getCellData(i, "personality");
        if (personality) {
            personalityArray.push(personality);
        }
    }
    
    // 데이터 설정
    dmp_postVo.set("companyId", companyId);
    dmp_postVo.set("postedAt", dateString);
    dmp_postVo.set("expiresAt", expiryString);
    dmp_postVo.set("status", "active");
    dmp_postVo.set("selectedTechStackNames", JSON.stringify(techStackArray));
    dmp_postVo.set("preferredDeveloperTypes", JSON.stringify(personalityArray));
    
    // 파일 업로드 실행 (CreateCompany 방식)
    scwin.uploadJobImage();
    
    console.log("등록 데이터:", {
        companyId: companyId,
        title: dmp_postVo.get("title"),
        techStacks: techStackArray.length,
        personalities: personalityArray.length,
        jobImageFileName: dmp_postVo.get("jobImageFileName") || "없음"
    });
    
    // 서버 전송
    $p.executeSubmission("sbm_insertPost");
};

// 등록 완료 처리
scwin.sbm_insertPost_submitdone = function(e) {
    console.log("=== 서버 응답 ===", e);
    
    var elHeader = e.responseJSON ? e.responseJSON.elHeader : null;
    
    if (!elHeader || elHeader.resSuc === false) {
        var errorCode = elHeader ? elHeader.resCode : "Unknown";
        var errorMsg = elHeader ? elHeader.resMsg : "서버 응답 없음";
        $c.win.alert("등록 실패\n코드: " + errorCode + "\n메시지: " + errorMsg);
        return;
    }
    
    $c.win.alert("공고가 성공적으로 등록되었습니다!");
    $p.url("../corporate/RecruitmentDashboard.xml");
};

// ... existing code ...
window.scwin = window.scwin || {};
window.scwin.removeTechStackByName = scwin.removeTechStackByName;
// ... existing code ...
]]></script>
    </head>
    
    <body ev:onpageload="scwin.onpageload">
        <w2:wframe src="../common/Header.xml" id="headerFrame" />
        
        <xf:group class="main-container">
            <xf:group class="content-container">
                <!-- 페이지 헤더 -->
                <xf:group class="page-header">
                    <w2:textbox class="main-title" label="공고 등록"></w2:textbox>
                    <w2:textbox class="page-subtitle" label="우리 회사의 매력적인 공고를 등록해보세요"></w2:textbox>
                </xf:group>

                <!-- 기본 정보 섹션 -->
<section class="form-section">
    <w2:textbox class="section-title" label="기본 정보"></w2:textbox>
    
    <xf:group class="form-group">
        <w2:textbox class="form-label required" label="공고 제목"></w2:textbox>
        <xf:input class="form-input" placeholder="매력적인 공고 제목을 입력해주세요" ref="data:dmp_postVo.title"></xf:input>
    </xf:group>
    
    <xf:group class="form-row">
        <xf:group class="form-group half">
            <w2:textbox class="form-label required" label="근무 지역"></w2:textbox>
            <xf:select1 class="form-select" chooseOption="지역 선택" appearance="minimal" ref="data:dmp_postVo.location" style="width: 100%; height: 56px; padding: 0 16px; border: 2px solid #e5e7eb; border-radius: 12px; font-size: 16px; color: #333; background-color: #ffffff; transition: all 0.2s ease; box-sizing: border-box;">
                <xf:choices>
                    <xf:item><xf:label><![CDATA[서울]]></xf:label><xf:value><![CDATA[서울]]></xf:value></xf:item>
                    <xf:item><xf:label><![CDATA[경기]]></xf:label><xf:value><![CDATA[경기]]></xf:value></xf:item>
                    <xf:item><xf:label><![CDATA[인천]]></xf:label><xf:value><![CDATA[인천]]></xf:value></xf:item>
                    <xf:item><xf:label><![CDATA[부산]]></xf:label><xf:value><![CDATA[부산]]></xf:value></xf:item>
                    <xf:item><xf:label><![CDATA[대구]]></xf:label><xf:value><![CDATA[대구]]></xf:value></xf:item>
                    <xf:item><xf:label><![CDATA[대전]]></xf:label><xf:value><![CDATA[대전]]></xf:value></xf:item>
                    <xf:item><xf:label><![CDATA[광주]]></xf:label><xf:value><![CDATA[광주]]></xf:value></xf:item>
                </xf:choices>
            </xf:select1>
        </xf:group>
        
        <xf:group class="form-group half">
            <w2:textbox class="form-label required" label="근무 형태"></w2:textbox>
            <xf:select1 class="form-select" chooseOption="형태 선택" appearance="minimal" ref="data:dmp_postVo.workType" style="width: 100%; height: 56px; padding: 0 16px; border: 2px solid #e5e7eb; border-radius: 12px; font-size: 16px; color: #333; background-color: #ffffff; transition: all 0.2s ease; box-sizing: border-box;">
                <xf:choices>
                    <xf:item><xf:label><![CDATA[원격 근무]]></xf:label><xf:value><![CDATA[remote]]></xf:value></xf:item>
                    <xf:item><xf:label><![CDATA[출근 근무]]></xf:label><xf:value><![CDATA[onsite]]></xf:value></xf:item>
                    <xf:item><xf:label><![CDATA[하이브리드]]></xf:label><xf:value><![CDATA[hybrid]]></xf:value></xf:item>
                </xf:choices>
            </xf:select1>
        </xf:group>
    </xf:group>
</section>

                <!-- 기술스택 섹션 -->
                <section class="form-section">
                    <w2:textbox class="section-title" label="💻 기술스택"></w2:textbox>

                    <xf:group class="form-group">
                        <w2:textbox class="form-label required" label="주요 기술스택"></w2:textbox>
                        <w2:textbox class="help-text" label="입력창을 클릭하면 인기 기술스택이 표시되고, 타이핑하면 자동완성 추천이 나타납니다. 선택한 기술스택은 아래에 태그로 표시되며 × 버튼으로 제거할 수 있습니다."></w2:textbox>
                        
                        <!-- 기술스택 카드 그리드 -->
                        <xf:group class="techstack-grid">
                            <!-- 기술스택 카드들은 JavaScript에서 동적으로 생성됩니다 -->
                        </xf:group>
                        
                        <xf:group class="techstack-input-container">
                            <xf:input class="form-input" id="input_techstack" placeholder="기술스택을 입력하세요 (예: React, Java, Docker)" 
                                ev:oninput="scwin.input_techstack_oninput" ev:onkeypress="scwin.input_techstack_onkeypress"
                                ev:onfocus="scwin.input_techstack_onfocus" ev:onblur="scwin.input_techstack_onblur"></xf:input>
                            <xf:trigger class="btn-add-techstack" type="button" ev:onclick="scwin.addTechStackFromInput">
                                <xf:label><![CDATA[추가]]></xf:label>
                            </xf:trigger>
                            <div id="techstack-suggestions" class="techstack-suggestions"></div>
                        </xf:group>

                        <!-- 선택된 기술스택 표시 영역 (이제 사용하지 않음 - 회색 박스에 표시) -->
                        <xf:group class="selected-techstack-container" style="display: none;">
                            <!-- 기술스택 태그들이 여기에 동적으로 추가됩니다 -->
                        </xf:group>
                    </xf:group>
                </section>

                <!-- 선호 성향 섹션 -->
                <section class="form-section">
                    <w2:textbox class="section-title" label="🎯 선호 성향"></w2:textbox>

                    <xf:group class="form-group personality-section" style="position: relative;">
                        <w2:textbox class="form-label required" label="선호하는 개발자 성향 (최대 4개)"></w2:textbox>
                        <div class="personality-counter">0/4</div>
                        
                        <xf:group class="personality-grid">
                            <!-- E*** -->
                            <xf:trigger class="personality-btn" type="button" id="personality_ERSD" ev:onclick="scwin.personality_btn_onclick"><xf:label><![CDATA[ERSD]]></xf:label></xf:trigger>
                            <xf:trigger class="personality-btn" type="button" id="personality_ERSF" ev:onclick="scwin.personality_btn_onclick"><xf:label><![CDATA[ERSF]]></xf:label></xf:trigger>
                            <xf:trigger class="personality-btn" type="button" id="personality_ERTD" ev:onclick="scwin.personality_btn_onclick"><xf:label><![CDATA[ERTD]]></xf:label></xf:trigger>
                            <xf:trigger class="personality-btn" type="button" id="personality_ERTF" ev:onclick="scwin.personality_btn_onclick"><xf:label><![CDATA[ERTF]]></xf:label></xf:trigger>
                            <xf:trigger class="personality-btn" type="button" id="personality_EISD" ev:onclick="scwin.personality_btn_onclick"><xf:label><![CDATA[EISD]]></xf:label></xf:trigger>
                            <xf:trigger class="personality-btn" type="button" id="personality_EISF" ev:onclick="scwin.personality_btn_onclick"><xf:label><![CDATA[EISF]]></xf:label></xf:trigger>
                            <xf:trigger class="personality-btn" type="button" id="personality_EITD" ev:onclick="scwin.personality_btn_onclick"><xf:label><![CDATA[EITD]]></xf:label></xf:trigger>
                            <xf:trigger class="personality-btn" type="button" id="personality_EITF" ev:onclick="scwin.personality_btn_onclick"><xf:label><![CDATA[EITF]]></xf:label></xf:trigger>
                            
                            <!-- B*** -->
                            <xf:trigger class="personality-btn" type="button" id="personality_BRSD" ev:onclick="scwin.personality_btn_onclick"><xf:label><![CDATA[BRSD]]></xf:label></xf:trigger>
                            <xf:trigger class="personality-btn" type="button" id="personality_BRSF" ev:onclick="scwin.personality_btn_onclick"><xf:label><![CDATA[BRSF]]></xf:label></xf:trigger>
                            <xf:trigger class="personality-btn" type="button" id="personality_BRTD" ev:onclick="scwin.personality_btn_onclick"><xf:label><![CDATA[BRTD]]></xf:label></xf:trigger>
                            <xf:trigger class="personality-btn" type="button" id="personality_BRTF" ev:onclick="scwin.personality_btn_onclick"><xf:label><![CDATA[BRTF]]></xf:label></xf:trigger>
                            <xf:trigger class="personality-btn" type="button" id="personality_BISD" ev:onclick="scwin.personality_btn_onclick"><xf:label><![CDATA[BISD]]></xf:label></xf:trigger>
                            <xf:trigger class="personality-btn" type="button" id="personality_BISF" ev:onclick="scwin.personality_btn_onclick"><xf:label><![CDATA[BISF]]></xf:label></xf:trigger>
                            <xf:trigger class="personality-btn" type="button" id="personality_BITD" ev:onclick="scwin.personality_btn_onclick"><xf:label><![CDATA[BITD]]></xf:label></xf:trigger>
                            <xf:trigger class="personality-btn" type="button" id="personality_BITF" ev:onclick="scwin.personality_btn_onclick"><xf:label><![CDATA[BITF]]></xf:label></xf:trigger>
                        </xf:group>
                        
                        <w2:textbox class="help-text" label="우리 팀과 잘 맞을 것 같은 성향 유형을 선택해주세요"></w2:textbox>
                    </xf:group>
                </section>

                <!-- 추가 정보 섹션 -->
                <section class="form-section">
                    <w2:textbox class="section-title" label="📋 추가 정보"></w2:textbox>
                    
                    <xf:group class="form-row">
                        <xf:group class="form-group half">
                            <w2:textbox class="form-label" label="선호 경력"></w2:textbox>
                            <xf:select1 class="form-select" chooseOption="경력 선택" appearance="minimal" ref="data:dmp_postVo.experienceLevel">
                                <xf:choices>
                                    <xf:item><xf:label><![CDATA[상관없음]]></xf:label><xf:value><![CDATA[any]]></xf:value></xf:item>
                                    <xf:item><xf:label><![CDATA[신입 (0년)]]></xf:label><xf:value><![CDATA[new]]></xf:value></xf:item>
                                    <xf:item><xf:label><![CDATA[1-2년]]></xf:label><xf:value><![CDATA[junior]]></xf:value></xf:item>
                                    <xf:item><xf:label><![CDATA[3-5년]]></xf:label><xf:value><![CDATA[mid]]></xf:value></xf:item>
                                    <xf:item><xf:label><![CDATA[5년 이상]]></xf:label><xf:value><![CDATA[senior]]></xf:value></xf:item>
                                </xf:choices>
                            </xf:select1>
                        </xf:group>

                        <xf:group class="form-group half">
                            <w2:textbox class="form-label" label="예상 연봉범위"></w2:textbox>
                            <xf:select1 class="form-select" chooseOption="연봉 선택" appearance="minimal" ref="data:dmp_postVo.salaryRange">
                                <xf:choices>
                                    <xf:item><xf:label><![CDATA[2,500만원 미만]]></xf:label><xf:value><![CDATA[under25]]></xf:value></xf:item>
                                    <xf:item><xf:label><![CDATA[2,500-3,500만원]]></xf:label><xf:value><![CDATA[25to35]]></xf:value></xf:item>
                                    <xf:item><xf:label><![CDATA[3,500-5,000만원]]></xf:label><xf:value><![CDATA[35to50]]></xf:value></xf:item>
                                    <xf:item><xf:label><![CDATA[5,000만원 이상]]></xf:label><xf:value><![CDATA[over50]]></xf:value></xf:item>
                                </xf:choices>
                            </xf:select1>
                        </xf:group>
                    </xf:group>

                    <xf:group class="form-group">
                        <w2:textbox class="form-label required" label="상세 설명"></w2:textbox>
                        <xf:textarea class="form-textarea" placeholder="우리 회사에서 함께 일하고 싶은 개발자의 특징이나 역량을 구체적으로 설명해주세요." ref="data:dmp_postVo.description"></xf:textarea>
                    </xf:group>

                    <!-- 이미지 업로드 (CreateCompany 방식 완전 적용) -->
                    <xf:group class="form-group">
                        <w2:textbox class="form-label" label="공고 이미지 (선택사항)"></w2:textbox>
                        <xf:group class="upload-container" id="job_image_upload_container">
                            <w2:textbox class="upload-label" label="PNG, JPG 파일 업로드 (최대 5MB)"></w2:textbox>
                            <w2:upload imageStyle="position:absolute;vertical-align:middle;word-wrap:break-word"
                                inputStyle="vertical-align:middle;word-wrap:break-word" style="width: 250px;height: 23px;" id="job_image_upload"
                                ev:ondone="scwin.job_image_upload_ondone" ev:onInputValueChange="scwin.job_image_upload_onInputValueChange">
                            </w2:upload>

                            <div id="job_image_file_info" class="file-info">
                                <span class="file-name" id="job_image_file_name"></span>
                                <div>✓ 파일이 선택되었습니다</div>
                            </div>
                        </xf:group>
                    </xf:group>
                </section>

                <!-- 버튼 그룹 -->
                <section class="form-section">
                    <xf:group class="button-container">
                        <xf:trigger class="btn-cancel" type="button" ev:onclick="scwin.btn_cancel_onclick">
                            <xf:label><![CDATA[취소]]></xf:label>
                        </xf:trigger>
                        <xf:trigger class="btn-primary" type="button" ev:onclick="scwin.btn_create_post_onclick">
                            <xf:label><![CDATA[🚀 공고 등록하기]]></xf:label>
                        </xf:trigger>
                    </xf:group>
                </section>
            </xf:group>
        </xf:group>
    </body>
</html>
