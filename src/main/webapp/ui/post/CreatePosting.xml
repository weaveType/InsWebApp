<?xml version="1.0" encoding="UTF-8"?>
<html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:ev="http://www.w3.org/2001/xml-events"
    xmlns:w2="http://www.inswave.com/websquare" 
    xmlns:xf="http://www.w3.org/2002/xforms">
    
    <head meta_screenName="회사 메인페이지">
        <w2:type>COMPONENT</w2:type>
        <w2:buildDate/>
        <w2:MSA/>
        <xf:model>
            <w2:dataCollection baseNode="map">
            	<w2:dataList baseNode="list" repeatNode="map" id="dlt_techstack" saveRemovedData="true">
            		<w2:columnInfo>
            			<w2:column dataType="text" name="techstack" id="techstack"></w2:column>
            		</w2:columnInfo>
            	</w2:dataList>
            	<w2:dataList baseNode="list" repeatNode="map" id="dlt_personalities" saveRemovedData="true">
            		<w2:columnInfo>
            			<w2:column dataType="text" name="personality" id="personality"></w2:column>
            		</w2:columnInfo>
            	</w2:dataList>
            	<!-- 서버에서 가져온 전체 기술스택 목록 -->
            	<w2:dataList baseNode="list" repeatNode="map" id="dlt_all_techstacks" saveRemovedData="true">
            		<w2:columnInfo>
            			<w2:column dataType="text" name="techStackId" id="techStackId"></w2:column>
            			<w2:column dataType="text" name="techStackName" id="techStackName"></w2:column>
            		</w2:columnInfo>
            	</w2:dataList>
            	<w2:dataMap baseNode="map" id="dmp_postVo" style="">
            		<w2:keyInfo>
            			<w2:key dataType="text" id="jobPostingId" name="job_posting_id"></w2:key>
            			<w2:key dataType="text" id="companyId" name="company_id"></w2:key>
            			<w2:key dataType="text" id="title" name="title"></w2:key>
            			<w2:key dataType="text" id="description" name="description"></w2:key>
            			<w2:key dataType="text" id="selectedTechStackNames" name="selected_tech_stack_names"></w2:key>
            			<w2:key dataType="text" id="experienceLevel" name="experience_level"></w2:key>
            			<w2:key dataType="text" id="salaryRange" name="salary_range"></w2:key>
            			<w2:key dataType="text" id="location" name="location"></w2:key>
            			<w2:key dataType="text" id="workType" name="work_type"></w2:key>
            			<w2:key dataType="text" id="preferredDeveloperTypes" name="preferred_developer_types"></w2:key>
            			<w2:key dataType="text" id="expiresAt" name="expires_at"></w2:key>
            			<w2:key dataType="text" id="postedAt" name="posted_at"></w2:key>
            			<w2:key dataType="text" id="status" name="status"></w2:key>
            		</w2:keyInfo>
            	</w2:dataMap>
            </w2:dataCollection>
            <w2:workflowCollection/>
            
            <xf:submission id="sbm_insertPost" ref='data:json,{"id":"dmp_postVo","key":"postVo"}' target="" action="/InsWebApp/POS0001Ins.pwkjson" method="post"
            	mediatype="application/json" encoding="UTF-8" instance="" replace="" errorHandler="" customHandler="" mode="asynchronous" processMsg="공고를 등록 중입니다."
            	ev:submit="" ev:submitdone="scwin.sbm_insertPost_submitdone" ev:submiterror="" abortTrigger="">
            </xf:submission>
            
            <xf:submission id="sbm_selectTechStackList" ref="" target="data:json,dlt_all_techstacks" action="/InsWebApp/POS0002List.pwkjson" method="post"
            	mediatype="application/json" encoding="UTF-8" instance="" replace="" errorHandler="" customHandler="" mode="asynchronous" processMsg="기술스택 목록을 불러오는 중입니다."
            	ev:submit="" ev:submitdone="scwin.sbm_selectTechStackList_submitdone" ev:submiterror="" abortTrigger="">
            </xf:submission>
        </xf:model>
        <w2:layoutInfo/>
        <w2:publicInfo method=""/>
        
        <style type="text/css"><![CDATA[
            /* 전체 컨테이너 스타일 */
            .main-container {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                min-height: 100vh;
                padding: 20px;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                position: relative;
                overflow-x: hidden;
            }
            
            /* 배경 장식 요소 */
            .background-decoration {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                pointer-events: none;
                z-index: 0;
                overflow: hidden;
            }
            
            .floating-shape {
                position: absolute;
                background: rgba(255, 255, 255, 0.1);
                border-radius: 50%;
                animation: float 6s ease-in-out infinite;
            }
            
            .shape-1 {
                width: 120px;
                height: 120px;
                top: 10%;
                left: 5%;
                animation-delay: 0s;
            }
            
            .shape-2 {
                width: 80px;
                height: 80px;
                top: 60%;
                right: 10%;
                animation-delay: 2s;
            }
            
            .shape-3 {
                width: 150px;
                height: 150px;
                bottom: 15%;
                left: 15%;
                animation-delay: 4s;
            }
            
            .shape-4 {
                width: 60px;
                height: 60px;
                top: 30%;
                right: 30%;
                animation-delay: 1s;
            }
            
            @keyframes float {
                0%, 100% {
                    transform: translateY(0px) rotate(0deg);
                    opacity: 0.6;
                }
                50% {
                    transform: translateY(-30px) rotate(180deg);
                    opacity: 0.8;
                }
            }
            
            /* 컨텐츠 컨테이너 */
            .content-container {
                position: relative;
                z-index: 1;
                max-width: 600px;
                margin: 0 auto;
            }
            
            /* 페이지 제목 스타일 */
            .page-header {
                text-align: center;
                margin-bottom: 50px;
                animation: slideDown 0.8s ease-out;
            }
            
            .main-title {
                font-size: 32px;
                font-weight: 700;
                color: #ffffff;
                margin: 0 0 12px 0;
                text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
                letter-spacing: -0.5px;
            }
            
            .page-subtitle {
                font-size: 16px;
                color: rgba(255, 255, 255, 0.9);
                margin: 0;
                font-weight: 400;
            }
            
            /* 헤더 아이콘 */
            .header-icon {
                font-size: 48px;
                margin-bottom: 20px;
                animation: bounce 2s infinite;
            }
            
            @keyframes bounce {
                0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
                40% { transform: translateY(-10px); }
                60% { transform: translateY(-5px); }
            }
            
            @keyframes slideDown {
                from {
                    opacity: 0;
                    transform: translateY(-30px);
                }
                to {
                    opacity: 1;
                    transform: translateY(0);
                }
            }
            
            /* 섹션 스타일 */
            .form-section {
                background: rgba(255, 255, 255, 0.95);
                backdrop-filter: blur(10px);
                border-radius: 20px;
                padding: 40px 32px;
                margin-bottom: 32px;
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
                border: 1px solid rgba(255, 255, 255, 0.2);
                animation: slideUp 0.6s ease-out;
                transition: all 0.3s ease;
            }
            
            .form-section:hover {
                transform: translateY(-5px);
                box-shadow: 0 12px 40px rgba(0, 0, 0, 0.15);
            }
            
            @keyframes slideUp {
                from {
                    opacity: 0;
                    transform: translateY(30px);
                }
                to {
                    opacity: 1;
                    transform: translateY(0);
                }
            }
            
            .section-title {
                font-size: 22px;
                font-weight: 700;
                color: #2d3748;
                margin-bottom: 32px;
                display: flex;
                align-items: center;
                gap: 12px;
            }
            
            .section-icon {
                font-size: 24px;
                width: 40px;
                height: 40px;
                border-radius: 12px;
                display: flex;
                align-items: center;
                justify-content: center;
                background: linear-gradient(135deg, #667eea, #764ba2);
                color: white;
            }
            
            /* 폼 그룹 스타일 */
            .form-group {
                margin-bottom: 32px;
                position: relative;
            }
            
            .form-group.half {
                flex: 0 0 calc(50% - 10px);
            }
            
            .form-row {
                display: flex;
                gap: 20px;
                margin-bottom: 20px;
                align-items: flex-start;
            }
            
            .form-label {
                display: block;
                font-size: 16px;
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 12px;
                letter-spacing: -0.3px;
            }
            
            .form-label.required::after {
                content: " *";
                color: #e53e3e;
                font-weight: bold;
            }
            
            /* 입력 필드 스타일 */
            .form-input {
                width: 100%;
                height: 56px;
                padding: 0 20px;
                border: 2px solid #e2e8f0;
                border-radius: 16px;
                font-size: 16px;
                color: #2d3748;
                background-color: #ffffff;
                transition: all 0.3s ease;
                box-sizing: border-box;
            }
            
            .form-input:focus {
                outline: none;
                border-color: #667eea;
                box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.1);
                transform: translateY(-2px);
                border-bottom-left-radius: 16px;
                border-bottom-right-radius: 16px;
            }
            
            /* 자동완성이 보일 때 입력 필드 스타일 */
            .form-input:focus + .techstack-suggestions[style*="block"] {
                border-top-left-radius: 0;
                border-top-right-radius: 0;
            }
            
            .form-input::placeholder {
                color: #a0aec0;
                font-weight: 400;
            }
            
            /* 선택 박스 스타일 */
            .form-select {
                width: 200px !important;
                height: 56px !important;
                padding: 0 20px !important;
                border: 2px solid #e2e8f0 !important;
                border-radius: 16px !important;
                font-size: 16px !important;
                color: #2d3748 !important;
                background-color: #ffffff !important;
                background-position: right 16px center !important;
                background-repeat: no-repeat !important;
                background-size: 16px !important;
                appearance: none !important;
                cursor: pointer !important;
                transition: all 0.3s ease !important;
                box-sizing: border-box !important;
            }
            
            .form-select:focus {
                outline: none !important;
                border-color: #667eea !important;
                box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.1) !important;
                transform: translateY(-2px) !important;
            }
            
            /* AutoComplete 스타일 */
            .w2-autocomplete-container {
                width: 100% !important;
            }
            
            .w2-autocomplete-container input {
                width: 100% !important;
                height: 56px !important;
                padding: 0 20px !important;
                border: 2px solid #e2e8f0 !important;
                border-radius: 16px !important;
                font-size: 16px !important;
                color: #2d3748 !important;
                background-color: #ffffff !important;
                transition: all 0.3s ease !important;
                box-sizing: border-box !important;
            }
            
            .w2-autocomplete-container input:focus {
                outline: none !important;
                border-color: #667eea !important;
                box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.1) !important;
                transform: translateY(-2px) !important;
            }
            
            /* 텍스트 영역 스타일 */
            .form-textarea {
                width: 100%;
                min-height: 120px;
                padding: 20px;
                border: 2px solid #e2e8f0;
                border-radius: 16px;
                font-size: 16px;
                color: #2d3748;
                background-color: #ffffff;
                font-family: inherit;
                resize: vertical;
                transition: all 0.3s ease;
                box-sizing: border-box;
            }
            
            .form-textarea:focus {
                outline: none;
                border-color: #667eea;
                box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.1);
                transform: translateY(-2px);
            }
            
            .form-textarea::placeholder {
                color: #a0aec0;
                font-weight: 400;
            }
            
            /* 기술스택 선택 카드 그리드 */
            .techstack-grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
                gap: 12px;
                margin: 20px 0;
            }
            
            .techstack-card {
                background: linear-gradient(135deg, #f7fafc, #edf2f7);
                border: 2px solid #e2e8f0;
                border-radius: 16px;
                padding: 16px 12px;
                text-align: center;
                cursor: pointer;
                transition: all 0.3s ease;
                font-size: 14px;
                font-weight: 600;
                color: #4a5568;
                position: relative;
                overflow: hidden;
            }
            
            .techstack-card::before {
                content: '';
                position: absolute;
                top: 0;
                left: -100%;
                width: 100%;
                height: 100%;
                background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.6), transparent);
                transition: left 0.5s;
            }
            
            .techstack-card:hover::before {
                left: 100%;
            }
            
            .techstack-card:hover {
                transform: translateY(-3px) scale(1.05);
                border-color: #667eea;
                background: linear-gradient(135deg, #667eea, #764ba2);
                color: white;
                box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3);
            }
            
            .techstack-card.selected {
                background: linear-gradient(135deg, #48bb78, #38a169) !important;
                color: white !important;
                border-color: #48bb78 !important;
                transform: scale(0.95) !important;
                box-shadow: 0 4px 20px rgba(72, 187, 120, 0.4) !important;
            }
            
            .techstack-card.selected:hover {
                background: linear-gradient(135deg, #38a169, #2f855a) !important;
                transform: scale(0.95) !important;
            }
            
            .techstack-card.selected label {
                color: white !important;
            }
            
            /* 선택된 기술스택 컨테이너 */
            .selected-techstack-container {
                display: flex;
                flex-wrap: wrap;
                gap: 12px;
                min-height: 20px;
                margin-top: 20px;
                padding: 20px;
                background: linear-gradient(135deg, #f0fff4, #e6fffa);
                border-radius: 16px;
                border: 2px dashed #68d391;
            }
            
            .selected-techstack-container:empty::after {
                content: "선택된 기술스택이 여기에 표시됩니다";
                color: #68d391;
                font-style: italic;
                width: 100%;
                text-align: center;
                opacity: 0.7;
            }
            
            /* 기술스택 태그 스타일 */
            .techstack-tag {
                display: inline-flex;
                align-items: center;
                background: linear-gradient(135deg, #4299e1, #3182ce);
                border: none;
                border-radius: 25px;
                padding: 8px 16px;
                font-size: 14px;
                color: white;
                gap: 10px;
                font-weight: 500;
                box-shadow: 0 4px 12px rgba(66, 153, 225, 0.3);
                animation: slideIn 0.3s ease-out;
            }
            
            @keyframes slideIn {
                from {
                    opacity: 0;
                    transform: scale(0.8);
                }
                to {
                    opacity: 1;
                    transform: scale(1);
                }
            }
            
            .techstack-text {
                font-weight: 500;
                line-height: 1;
                border: none !important;
                background: transparent !important;
                padding: 0 !important;
                margin: 0 !important;
                height: auto !important;
                width: auto !important;
                color: white !important;
            }
            
            /* 제거 버튼 스타일 */
            .techstack-remove-btn {
                background: rgba(255, 255, 255, 0.2) !important;
                border: none !important;
                color: white !important;
                cursor: pointer !important;
                font-size: 16px !important;
                font-weight: bold !important;
                line-height: 1 !important;
                padding: 4px !important;
                width: 20px !important;
                height: 20px !important;
                display: flex !important;
                align-items: center !important;
                justify-content: center !important;
                border-radius: 50% !important;
                transition: all 0.2s ease !important;
            }
            
            .techstack-remove-btn:hover {
                background: rgba(255, 255, 255, 0.3) !important;
                transform: scale(1.1) !important;
            }
            
            /* 성향 버튼 그리드 스타일 */
            .personality-grid {
                display: grid;
                grid-template-columns: repeat(4, 1fr);
                gap: 16px;
                margin: 20px 0;
            }
            
            .personality-btn {
                padding: 20px 16px;
                border: 2px solid #e2e8f0;
                background: linear-gradient(135deg, #f7fafc, #edf2f7);
                border-radius: 16px;
                cursor: pointer;
                text-align: center;
                font-size: 16px;
                font-weight: 700;
                color: #4a5568;
                transition: all 0.3s ease;
                position: relative;
                min-height: 60px;
                display: flex;
                align-items: center;
                justify-content: center;
                overflow: hidden;
            }
            
            .personality-btn::before {
                content: '';
                position: absolute;
                top: 0;
                left: -100%;
                width: 100%;
                height: 100%;
                background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.6), transparent);
                transition: left 0.5s;
            }
            
            .personality-btn:hover::before {
                left: 100%;
            }
            
            .personality-btn:hover {
                transform: translateY(-3px) scale(1.05);
                border-color: #667eea;
                background: linear-gradient(135deg, #667eea, #764ba2);
                color: white;
                box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3);
            }
            
            .personality-btn.selected {
                background: linear-gradient(135deg, #48bb78, #38a169) !important;
                color: white !important;
                border-color: #48bb78 !important;
                transform: scale(0.95) !important;
                box-shadow: 0 4px 20px rgba(72, 187, 120, 0.4) !important;
            }
            
            .personality-btn.selected:hover {
                background: linear-gradient(135deg, #38a169, #2f855a) !important;
                transform: scale(0.95) !important;
            }
            
            .personality-btn.selected label {
                color: white !important;
            }
            
            .personality-btn.disabled {
                opacity: 0.4;
                cursor: not-allowed;
                background: #f7fafc;
                color: #a0aec0;
                pointer-events: none;
            }
            
            /* 도움말 텍스트 */
            .help-text {
                font-size: 14px;
                color: #718096;
                margin-top: 12px;
                line-height: 1.6;
                text-align: center;
                font-style: italic;
            }
            
            /* 카운터 표시 */
            .personality-counter {
                position: absolute;
                top: -10px;
                right: -10px;
                background: linear-gradient(135deg, #ed8936, #dd6b20);
                color: white;
                padding: 6px 12px;
                border-radius: 20px;
                font-size: 12px;
                font-weight: 700;
                box-shadow: 0 4px 12px rgba(237, 137, 54, 0.4);
                animation: pulse 2s infinite;
            }
            
            @keyframes pulse {
                0% { transform: scale(1); }
                50% { transform: scale(1.1); }
                100% { transform: scale(1); }
            }
            
            /* 버튼 스타일 */
            .button-container {
                display: flex;
                gap: 16px;
                margin-top: 60px;
                padding: 0 4px;
            }
            
            .btn-cancel {
                flex: 1;
                height: 60px;
                border: 2px solid #e2e8f0;
                border-radius: 16px;
                background: linear-gradient(135deg, #f7fafc, #edf2f7);
                color: #4a5568;
                font-size: 16px;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.3s ease;
            }
            
            .btn-cancel:hover {
                transform: translateY(-3px);
                border-color: #cbd5e0;
                background: linear-gradient(135deg, #edf2f7, #e2e8f0);
                box-shadow: 0 8px 25px rgba(160, 174, 192, 0.3);
            }
            
            .btn-primary {
                flex: 1;
                height: 60px;
                border: none;
                border-radius: 16px;
                background: linear-gradient(135deg, #667eea, #764ba2);
                color: #ffffff;
                font-size: 16px;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.3s ease;
                box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
            }
            
            .btn-primary:hover {
                transform: translateY(-3px);
                background: linear-gradient(135deg, #5a67d8, #6b46c1);
                box-shadow: 0 12px 35px rgba(102, 126, 234, 0.5);
            }
            
            .btn-primary:disabled {
                background: linear-gradient(135deg, #e2e8f0, #cbd5e0);
                color: #a0aec0;
                cursor: not-allowed;
                transform: none;
                box-shadow: none;
            }
            
            /* 기술스택 추가 버튼 스타일 */
            .btn-add-techstack {
                height: 56px !important;
                padding: 0 20px !important;
                background: linear-gradient(135deg, #48bb78, #38a169) !important;
                color: white !important;
                border: none !important;
                border-radius: 12px !important;
                font-weight: 600 !important;
                cursor: pointer !important;
                transition: all 0.3s ease !important;
                box-shadow: 0 4px 12px rgba(72, 187, 120, 0.3) !important;
            }
            
            .btn-add-techstack:hover {
                background: linear-gradient(135deg, #38a169, #2f855a) !important;
                transform: translateY(-2px) !important;
                box-shadow: 0 6px 16px rgba(72, 187, 120, 0.4) !important;
            }
            
            /* 자동완성 추천 목록 스타일 */
            .techstack-suggestions {
                position: absolute;
                top: 100%;
                left: 0;
                right: 0;
                background: white;
                border: 2px solid #667eea;
                border-top: none;
                border-radius: 0 0 12px 12px;
                box-shadow: 0 4px 12px rgba(102, 126, 234, 0.2);
                max-height: 200px;
                overflow-y: auto;
                z-index: 1000;
                margin-top: -2px;
            }
            
            .suggestion-item {
                padding: 12px 16px;
                cursor: pointer;
                border-bottom: 1px solid #f1f3f4;
                transition: all 0.2s ease;
                display: flex;
                align-items: center;
                gap: 8px;
            }
            
            .suggestion-item:hover {
                background-color: #f8fafc;
                color: #667eea;
            }
            
            .suggestion-item:last-child {
                border-bottom: none;
            }
            
            .suggestion-match {
                font-weight: 600;
                color: #2d3748;
                flex: 1;
            }
            
            .suggestion-match strong {
                color: #667eea;
                background-color: #e6f3ff;
                padding: 1px 2px;
                border-radius: 2px;
            }
            
            .suggestion-category {
                font-size: 12px;
                color: #9ca3af;
                background: #f3f4f6;
                padding: 2px 6px;
                border-radius: 4px;
                margin-left: auto;
                white-space: nowrap;
            }
            
            /* 반응형 디자인 */
            @media (max-width: 768px) {
                .main-container {
                    padding: 15px;
                }
                
                .content-container {
                    max-width: 100%;
                }
                
                .main-title {
                    font-size: 26px;
                }
                
                .form-section {
                    padding: 30px 24px;
                    margin-bottom: 24px;
                }
                
                .personality-grid {
                    grid-template-columns: repeat(2, 1fr);
                    gap: 12px;
                }
                
                .techstack-grid {
                    grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
                    gap: 10px;
                }
                
                .form-row {
                    flex-direction: column;
                    gap: 20px;
                }
                
                .form-group.half {
                    flex: none;
                }
            }
            
            @media (max-width: 480px) {
                .personality-grid {
                    grid-template-columns: 1fr;
                }
                
                .techstack-grid {
                    grid-template-columns: repeat(2, 1fr);
                }
            }
        ]]></style>
        
        <script lazy="false" type="text/javascript"><![CDATA[
// 디버깅 모드 설정 (false로 설정하면 대부분의 로그가 숨겨짐)
scwin.DEBUG_MODE = false;

// 디버그 로그 함수
scwin.debugLog = function(message, data) {
    if (scwin.DEBUG_MODE) {
        if (data !== undefined) {
            console.log(message, data);
        } else {
            console.log(message);
        }
    }
};

scwin.onpageload = function () {
    // 성향 선택 관련 변수 초기화
    scwin.maxPersonalities = 4;
    scwin.selectedPersonalities = [];
    scwin.updatePersonalityCounter();
    
    // 서버에서 기술스택 목록 불러오기
    console.log("=== 기술스택 목록 불러오기 시작 ===");
    $p.executeSubmission("sbm_selectTechStackList");
    
    // 페이지 로드 애니메이션 시작
    setTimeout(function() {
        var sections = document.querySelectorAll('.form-section');
        sections.forEach(function(section, index) {
            setTimeout(function() {
                section.style.animationDelay = (index * 0.2) + 's';
            }, index * 200);
        });
    }, 100);
    
    // Generator 초기화 및 상태 확인
    setTimeout(function() {
        try {
            scwin.debugLog("=== 페이지 로드 후 초기 상태 확인 ===");
            scwin.debugLog("기술스택 데이터리스트 개수:", dlt_techstack.getRowCount());
            scwin.debugLog("성향 데이터리스트 개수:", dlt_personalities.getRowCount());
            
            // Generator 강제 새로고침
            if (typeof gen_techstack !== 'undefined') {
                gen_techstack.refresh();
                scwin.debugLog("기술스택 Generator 초기 새로고침 완료");
            }
            
            // 카드 상태 초기화
            scwin.updateTechStackCards();
            scwin.updatePersonalityButtons();
            
        } catch (error) {
            console.error("페이지 로드 후 초기화 오류:", error);
        }
    }, 1500);
    
    // 성향 버튼 이벤트 위임 추가 (백업용)
    setTimeout(function() {
        scwin.debugLog("=== 이벤트 위임 설정 시작 ===");
        
        // 성향 섹션에 이벤트 위임 추가
        var personalitySection = document.querySelector('.personality-section');
        if (personalitySection) {
            personalitySection.addEventListener('click', function(e) {
                scwin.debugLog("이벤트 위임으로 클릭 감지됨");
                
                // 성향 버튼 관련 요소인지 확인
                var target = e.target;
                var isPersonalityClick = false;
                
                // 클릭된 요소나 상위 요소가 성향 버튼인지 확인
                var currentElement = target;
                var maxDepth = 5;
                var depth = 0;
                
                while (currentElement && depth < maxDepth) {
                    if (currentElement.classList && (
                        currentElement.classList.contains('personality-btn') ||
                        currentElement.className.indexOf('personality') !== -1
                    )) {
                        isPersonalityClick = true;
                        scwin.debugLog("성향 버튼 클릭으로 판단됨");
                        break;
                    }
                    
                    // 텍스트에서 성향 패턴 확인
                    if (currentElement.textContent) {
                        var text = currentElement.textContent.trim();
                        if (/^[ABCD][RIT][STF][DF]$/.test(text)) {
                            isPersonalityClick = true;
                            scwin.debugLog("성향 패턴으로 클릭 판단됨");
                            break;
                        }
                    }
                    
                    currentElement = currentElement.parentNode;
                    depth++;
                }
                
                if (isPersonalityClick) {
                    scwin.debugLog("이벤트 위임에서 성향 버튼 클릭 처리");
                    // 기존 클릭 핸들러 호출
                    scwin.personality_btn_onclick(e);
                }
            });
            
            scwin.debugLog("성향 섹션에 이벤트 위임 추가 완료");
        }
        
        scwin.debugLog("=== 이벤트 위임 설정 완료 ===");
    }, 2000);
};

// 기술스택 목록 조회 완료 후 처리
scwin.sbm_selectTechStackList_submitdone = function(e) {
    console.log("=== 기술스택 목록 조회 완료 ===");
    console.log("응답 데이터:", e.responseJSON);
    
    try {
        // 서버에서 받은 기술스택 데이터로 전역 변수 설정
        scwin.allTechStacks = [];
        scwin.techStacksMap = {}; // 이름 -> ID 매핑
        
        // 서버 응답에서 techStackVoList 배열 가져오기
        var techStackList = e.responseJSON && e.responseJSON.techStackVoList ? e.responseJSON.techStackVoList : [];
        console.log("서버에서 받은 기술스택 배열:", techStackList);
        console.log("받은 기술스택 개수:", techStackList.length);
        
        for (var i = 0; i < techStackList.length; i++) {
            var techStack = techStackList[i];
            var techStackId = techStack.techStackId;
            var techStackName = techStack.techStackName;
            
            if (techStackName) {
                scwin.allTechStacks.push(techStackName);
                scwin.techStacksMap[techStackName] = techStackId;
            }
        }
        
        console.log("처리된 기술스택 목록:", scwin.allTechStacks);
        console.log("기술스택 매핑:", scwin.techStacksMap);
        
        // 동적으로 기술스택 카드들 생성
        scwin.createTechStackCards();
        
        // 기술스택 그리드에 이벤트 위임 추가
        setTimeout(function() {
            scwin.addTechStackEventDelegation();
        }, 500);
        
    } catch (error) {
        console.error("기술스택 목록 처리 중 오류:", error);
        alert("기술스택 목록을 불러오는 중 오류가 발생했습니다.");
    }
};

// 동적으로 기술스택 카드들 생성
scwin.createTechStackCards = function() {
    console.log("=== 기술스택 카드 동적 생성 시작 ===");
    
    var techstackGrid = document.querySelector('.techstack-grid');
    if (!techstackGrid) {
        console.error("기술스택 그리드를 찾을 수 없습니다");
        return;
    }
    
    // 기존 하드코딩된 카드들 제거
    techstackGrid.innerHTML = '';
    
    // 인기 기술스택들을 우선적으로 표시 (12개)
    var popularTechStacks = ["Java", "JavaScript", "Python", "React", "Spring Boot", "Node.js", 
                            "MySQL", "MongoDB", "Docker", "Kubernetes", "Vue.js", "Angular"];
    
    var displayTechStacks = [];
    
    // 인기 기술스택 중 서버에 있는 것들 먼저 추가
    for (var i = 0; i < popularTechStacks.length; i++) {
        var techStack = popularTechStacks[i];
        if (scwin.allTechStacks.indexOf(techStack) !== -1) {
            displayTechStacks.push(techStack);
        }
    }
    
    // 12개가 안 되면 나머지 기술스택들로 채우기
    if (displayTechStacks.length < 12) {
        for (var i = 0; i < scwin.allTechStacks.length && displayTechStacks.length < 12; i++) {
            var techStack = scwin.allTechStacks[i];
            if (displayTechStacks.indexOf(techStack) === -1) {
                displayTechStacks.push(techStack);
            }
        }
    }
    
    console.log("표시할 기술스택들:", displayTechStacks);
    
    // 카드들 동적 생성
    for (var i = 0; i < displayTechStacks.length; i++) {
        var techStack = displayTechStacks[i];
        var cardId = "techstack_" + techStack.toLowerCase().replace(/[^a-z0-9]/g, '');
        
        var cardElement = document.createElement('div');
        cardElement.className = 'techstack-card';
        cardElement.id = cardId;
        cardElement.setAttribute('data-techstack', techStack);
        cardElement.style.cursor = 'pointer';
        
        var label = document.createElement('label');
        label.textContent = techStack;
        label.style.cursor = 'pointer';
        
        cardElement.appendChild(label);
        techstackGrid.appendChild(cardElement);
    }
    
    console.log("기술스택 카드 동적 생성 완료:", displayTechStacks.length + "개");
};

// 기술스택 그리드에 이벤트 위임 추가
scwin.addTechStackEventDelegation = function() {
    console.log("=== 기술스택 이벤트 위임 추가 ===");
    
    var techstackGrid = document.querySelector('.techstack-grid');
    if (!techstackGrid) {
        console.error("기술스택 그리드를 찾을 수 없습니다");
        return;
    }
    
    // 기존 이벤트 리스너 제거 방지를 위해 체크
    if (techstackGrid._eventDelegationAdded) {
        console.log("이미 이벤트 위임이 추가되어 있습니다");
        return;
    }
    
    techstackGrid.addEventListener('click', function(e) {
        var target = e.target;
        var techStackName = "";
        var cardElement = null;
        
        // 클릭된 요소가 카드나 라벨인지 확인
        if (target.classList.contains('techstack-card')) {
            cardElement = target;
            var label = cardElement.querySelector('label');
            if (label) {
                techStackName = label.textContent.trim();
            }
        } else if (target.tagName === 'LABEL' && target.parentElement.classList.contains('techstack-card')) {
            cardElement = target.parentElement;
            techStackName = target.textContent.trim();
        }
        
        if (cardElement && techStackName) {
            console.log("기술스택 카드 클릭됨:", techStackName);
            scwin.selectTechStackCard(techStackName, e);
        }
    });
    
    techstackGrid._eventDelegationAdded = true;
    console.log("기술스택 이벤트 위임 추가 완료");
};
scwin.input_techstack_oninput = function(e) {
    scwin.debugLog("=== 입력 이벤트 발생 ===");
    var inputValue = input_techstack.getValue();
    scwin.debugLog("입력값:", inputValue);
    
    // 약간의 지연을 두어 입력이 완료된 후 처리
    setTimeout(function() {
        scwin.showTechStackSuggestions(inputValue);
    }, 100);
};

scwin.input_techstack_onfocus = function(e) {
    scwin.debugLog("=== 입력 필드 포커스 ===");
    var inputValue = input_techstack.getValue();
    scwin.debugLog("포커스 시 입력값:", inputValue);
    
    if (inputValue && inputValue.trim() !== '') {
        setTimeout(function() {
            scwin.showTechStackSuggestions(inputValue);
        }, 100);
    }
};

scwin.input_techstack_onblur = function(e) {
    scwin.debugLog("=== 입력 필드 블러 ===");
    // 약간의 지연을 두어 클릭 이벤트가 먼저 처리되도록 함
    setTimeout(function() {
        scwin.hideTechStackSuggestions();
    }, 200);
};

// 기술스택 이름 정규화 (서버 데이터 사용) - 수정된 버전
scwin.normalizeTechStack = function(input) {
    if (!input || typeof input !== 'string') return null;
    if (!scwin.allTechStacks || scwin.allTechStacks.length === 0) return null;
    
    var inputLower = input.toLowerCase().trim();
    
    // 정확한 매칭 찾기
    for (var i = 0; i < scwin.allTechStacks.length; i++) {
        if (scwin.allTechStacks[i].toLowerCase() === inputLower) {
            return scwin.allTechStacks[i]; // 정식 이름 반환
        }
    }
    
    // 부분 매칭 시도
    for (var i = 0; i < scwin.allTechStacks.length; i++) {
        if (scwin.allTechStacks[i].toLowerCase().includes(inputLower) || 
            inputLower.includes(scwin.allTechStacks[i].toLowerCase())) {
            return scwin.allTechStacks[i]; // 정식 이름 반환
        }
    }
    
    return null; // 매칭되는 기술스택 없음
};

// 자동완성 추천 목록 보이기 (서버 데이터 사용) - 수정된 버전
scwin.showTechStackSuggestions = function(inputValue) {
    scwin.debugLog("=== 추천 목록 표시 시작 ===");
    scwin.debugLog("입력값:", inputValue);
    
    if (!scwin.allTechStacks || scwin.allTechStacks.length === 0) {
        scwin.debugLog("서버 기술스택 데이터가 아직 로드되지 않았습니다");
        return;
    }
    
    var suggestionsContainer = document.getElementById('techstack-suggestions');
    if (!suggestionsContainer) {
        console.error("추천 목록 컨테이너를 찾을 수 없습니다");
        return;
    }
    
    var input = inputValue ? inputValue.toLowerCase().trim() : '';
    
    if (input === '') {
        scwin.hideTechStackSuggestions();
        return;
    }
    
    // 이미 선택된 기술스택 목록
    var selectedTechStacks = [];
    for (var i = 0; i < dlt_techstack.getRowCount(); i++) {
        var techstack = dlt_techstack.getCellData(i, "techstack");
        if (techstack) {
            selectedTechStacks.push(techstack);
        }
    }
    
    scwin.debugLog("이미 선택된 기술스택:", selectedTechStacks);
    
    var suggestions = [];
    
    // 서버에서 받은 기술스택들에서 검색
    for (var i = 0; i < scwin.allTechStacks.length; i++) {
        var techStack = scwin.allTechStacks[i];
        
        // 이미 선택된 기술스택은 제외
        if (selectedTechStacks.indexOf(techStack) !== -1) continue;
        
        // 입력값과 매칭되는지 확인
        if (techStack.toLowerCase().includes(input)) {
            suggestions.push({
                name: techStack,
                category: "기술스택", // 서버 데이터는 카테고리 정보가 없으므로 기본값
                matchIndex: techStack.toLowerCase().indexOf(input)
            });
        }
    }
    
    scwin.debugLog("찾은 추천 목록:", suggestions);
    
    // 매칭 순서로 정렬 (앞부분 매칭이 우선)
    suggestions.sort(function(a, b) {
        if (a.matchIndex !== b.matchIndex) {
            return a.matchIndex - b.matchIndex;
        }
        return a.name.localeCompare(b.name);
    });
    
    // 최대 8개까지만 표시
    suggestions = suggestions.slice(0, 8);
    
    if (suggestions.length === 0) {
        scwin.debugLog("추천할 항목이 없습니다");
        scwin.hideTechStackSuggestions();
        return;
    }
    
    // HTML 생성 - 이벤트 위임 방식으로 변경
    var html = '';
    for (var i = 0; i < suggestions.length; i++) {
        var suggestion = suggestions[i];
        var highlightedName = scwin.highlightMatch(suggestion.name, input);
        var escapedName = suggestion.name.replace(/'/g, "&#39;").replace(/"/g, "&quot;");
        
        html += '<div class="suggestion-item" ' +
                'data-techstack="' + escapedName + '" ' +
                'style="cursor: pointer;">' +
                '<span class="suggestion-match">' + highlightedName + '</span>' +
                '<span class="suggestion-category">' + suggestion.category + '</span>' +
                '</div>';
    }
    
    scwin.debugLog("생성된 HTML:", html);
    
    suggestionsContainer.innerHTML = html;
    suggestionsContainer.style.display = 'block';
    
    // 이벤트 위임 설정 (한 번만 설정)
    if (!suggestionsContainer._eventSet) {
        suggestionsContainer.addEventListener('mousedown', function(e) {
            e.preventDefault();
            var target = e.target.closest('.suggestion-item');
            if (target) {
                var techStack = target.getAttribute('data-techstack');
                if (techStack) {
                    scwin.selectSuggestion(techStack);
                }
            }
            return false;
        });
        
        suggestionsContainer.addEventListener('click', function(e) {
            e.preventDefault();
            var target = e.target.closest('.suggestion-item');
            if (target) {
                var techStack = target.getAttribute('data-techstack');
                if (techStack) {
                    scwin.selectSuggestion(techStack);
                }
            }
            return false;
        });
        
        suggestionsContainer._eventSet = true;
    }
    
    scwin.debugLog("=== 추천 목록 표시 완료 ===");
};

// 자동완성 추천 목록 숨기기
scwin.hideTechStackSuggestions = function() {
    var suggestionsContainer = document.getElementById('techstack-suggestions');
    if (suggestionsContainer) {
        suggestionsContainer.style.display = 'none';
        scwin.debugLog("추천 목록 숨김");
    }
};

// 텍스트에서 매칭 부분 하이라이트
scwin.highlightMatch = function(text, match) {
    var index = text.toLowerCase().indexOf(match.toLowerCase());
    if (index === -1) return text;
    
    return text.substring(0, index) + 
           '<strong>' + text.substring(index, index + match.length) + '</strong>' + 
           text.substring(index + match.length);
};

// 추천 목록에서 기술스택 선택 - 직접 호출 방식으로 간소화
scwin.selectSuggestion = function(techStack) {
    scwin.debugLog("=== 추천 목록에서 선택됨 ===");
    scwin.debugLog("선택된 기술스택:", techStack);
    
    // 입력 필드에 값 설정
    input_techstack.setValue(techStack);
    
    // 추천 목록 숨기기
    scwin.hideTechStackSuggestions();
    
    // 바로 추가 처리
    scwin.debugLog("자동완성에서 선택된 기술스택을 바로 추가합니다.");
    
    // 이미 존재하는지 확인
    var selectedTechStacks = [];
    for (var i = 0; i < dlt_techstack.getRowCount(); i++) {
        var tech = dlt_techstack.getCellData(i, "techstack");
        if (tech) {
            selectedTechStacks.push(tech);
        }
    }
    
    if (selectedTechStacks.indexOf(techStack) === -1) {
        // 새로 추가
        var newRowIndex = dlt_techstack.insertRow();
        dlt_techstack.setCellData(newRowIndex, "techstack", techStack);
        
        scwin.debugLog("기술스택 추가됨:", techStack);
        
        // Generator 강제 새로고침
        try {
            gen_techstack.refresh();
            scwin.debugLog("Generator 새로고침 완료");
        } catch (error) {
            console.error("Generator 새로고침 오류:", error);
        }
        
        // 카드 상태 업데이트
        setTimeout(function() {
            scwin.updateTechStackCards();
        }, 200);
        
        // 입력 필드 초기화
        input_techstack.setValue("");
        
        console.log("✅ 자동완성 선택 및 추가 완료:", techStack);
        
    } else {
        scwin.debugLog("이미 존재하는 기술스택:", techStack);
        alert("이미 선택된 기술스택입니다.");
        // 입력 필드 초기화
        input_techstack.setValue("");
    }
};

// 입력 필드에서 기술스택 추가 - 자동완성 대응 및 Enter 키 지원
scwin.addTechStackFromInput = function(e) {
    if (e) {
        e.preventDefault();
        e.stopPropagation();
    }
    
    var inputValue = input_techstack.getValue();
    
    console.log("=== 기술스택 추가 시작 ===");
    console.log("입력된 기술스택:", inputValue);
    
    if (!inputValue || inputValue.trim() === "") {
        alert("기술스택을 입력해주세요.");
        return;
    }
    
    // 기술스택 정규화 (서버 데이터 사용)
    var normalizedTechStack = scwin.normalizeTechStack(inputValue);
    
    if (!normalizedTechStack) {
        alert("지원하지 않는 기술스택입니다.\n사용 가능한 기술스택 목록에서 선택해주세요.");
        return;
    }
    
    console.log("정규화된 기술스택:", normalizedTechStack);
    
    // 이미 존재하는지 확인
    var selectedTechStacks = [];
    for (var i = 0; i < dlt_techstack.getRowCount(); i++) {
        var tech = dlt_techstack.getCellData(i, "techstack");
        if (tech) {
            selectedTechStacks.push(tech);
        }
    }
    
    if (selectedTechStacks.indexOf(normalizedTechStack) === -1) {
        // 새로 추가
        var newRowIndex = dlt_techstack.insertRow();
        dlt_techstack.setCellData(newRowIndex, "techstack", normalizedTechStack);
        
        // Generator 강제 새로고침
        try {
            gen_techstack.refresh();
            console.log("Generator 새로고침 완료");
        } catch (error) {
            console.error("Generator 새로고침 오류:", error);
        }
        
        // 카드 상태 업데이트
        setTimeout(function() {
            scwin.updateTechStackCards();
        }, 200);
        
        // 입력 필드 초기화
        input_techstack.setValue("");
        
        // 추천 목록 숨기기
        scwin.hideTechStackSuggestions();
        
        console.log("기술스택 추가됨:", normalizedTechStack);
        
    } else {
        alert("이미 선택된 기술스택입니다.");
        console.log("이미 존재하는 기술스택:", normalizedTechStack);
    }
    
    console.log("=== 기술스택 추가 완료 ===");
};

// Enter 키 이벤트 처리
scwin.input_techstack_onkeypress = function(e) {
    if (e.keyCode === 13 || e.which === 13) {
        e.preventDefault();
        scwin.addTechStackFromInput();
    }
};

// 기술스택 카드 클릭 이벤트 (토글 기능 완전 수정)
scwin.selectTechStackCard = function(techStack, e) {
    console.log("=== 기술스택 카드 클릭 ===");
    console.log("클릭된 기술스택:", techStack);
    
    // 이벤트 전파 방지
    if (e) {
        e.preventDefault();
        e.stopPropagation();
    }
    
    if (!techStack) {
        console.error("기술스택 이름이 없습니다");
        return;
    }
    
    // 현재 선택된 기술스택 목록 정확히 확인
    var selectedTechStacks = [];
    var rowCount = dlt_techstack.getRowCount();
    console.log("현재 데이터리스트 행 개수:", rowCount);
    
    for (var i = 0; i < rowCount; i++) {
        var tech = dlt_techstack.getCellData(i, "techstack");
        if (tech && tech.trim() !== '') {
            selectedTechStacks.push(tech);
        }
    }
    
    console.log("현재 선택된 기술스택들:", selectedTechStacks);
    
    // 정확한 매칭 확인
    var foundIndex = -1;
    for (var i = 0; i < selectedTechStacks.length; i++) {
        if (selectedTechStacks[i] === techStack) {
            foundIndex = i;
            break;
        }
    }
    
    var isAlreadySelected = foundIndex !== -1;
    console.log(techStack + " 이미 선택됨:", isAlreadySelected, "인덱스:", foundIndex);
    
    if (isAlreadySelected) {
        // 선택 해제 - 직접 인덱스로 제거
        console.log("선택 해제 시작 - 인덱스:", foundIndex);
        
        try {
            dlt_techstack.removeRow(foundIndex);
            console.log("기술스택 제거 완료:", techStack);
        } catch (error) {
            console.error("기술스택 제거 오류:", error);
        }
    } else {
        // 새로 추가
        console.log("새로 추가 시작");
        try {
            var newRowIndex = dlt_techstack.insertRow();
            dlt_techstack.setCellData(newRowIndex, "techstack", techStack);
            console.log("기술스택 추가 완료:", techStack);
        } catch (error) {
            console.error("기술스택 추가 오류:", error);
        }
    }
    
    // Generator 강제 새로고침
    try {
        gen_techstack.refresh();
        console.log("Generator 새로고침 완료");
    } catch (error) {
        console.error("Generator 새로고침 오류:", error);
    }
    
    // 카드 상태 업데이트 (지연 실행으로 확실히 적용)
    setTimeout(function() {
        scwin.updateTechStackCards();
        
        // 처리 후 상태 확인
        console.log("=== 처리 후 기술스택 목록 ===");
        for (var i = 0; i < dlt_techstack.getRowCount(); i++) {
            var tech = dlt_techstack.getCellData(i, "techstack");
            console.log("기술스택 " + i + ":", tech);
        }
        console.log("=== 기술스택 카드 클릭 완료 ===");
    }, 200);
};

// 기술스택 카드 상태 업데이트 - 로그 정리
scwin.updateTechStackCards = function() {
    scwin.debugLog("=== 카드 상태 업데이트 시작 ===");
    
    // 현재 선택된 기술스택 목록 가져오기
    var selectedTechStacks = [];
    for (var i = 0; i < dlt_techstack.getRowCount(); i++) {
        var techstack = dlt_techstack.getCellData(i, "techstack");
        if (techstack) {
            selectedTechStacks.push(techstack);
        }
    }
    
    scwin.debugLog("현재 선택된 기술스택들:", selectedTechStacks);
    
    // 모든 가능한 선택자로 카드 찾기
    var cardSelectors = [
        '.techstack-card',
        '[class*="techstack"]',
        '[id*="techstack"]',
        'xf\\:trigger[class*="techstack"]',
        'input[class*="techstack"]'
    ];
    
    var allCards = [];
    
    // 각 선택자로 요소 찾기
    for (var s = 0; s < cardSelectors.length; s++) {
        try {
            var foundElements = document.querySelectorAll(cardSelectors[s]);
            scwin.debugLog("선택자 '" + cardSelectors[s] + "'로 찾은 요소 개수:", foundElements.length);
            
            for (var e = 0; e < foundElements.length; e++) {
                var element = foundElements[e];
                // 중복 제거
                var isDuplicate = false;
                for (var c = 0; c < allCards.length; c++) {
                    if (allCards[c] === element) {
                        isDuplicate = true;
                        break;
                    }
                }
                
                if (!isDuplicate) {
                    allCards.push(element);
                }
            }
        } catch (error) {
            scwin.debugLog("선택자 '" + cardSelectors[s] + "' 사용 중 오류:", error);
        }
    }
    
    scwin.debugLog("총 찾은 카드 개수:", allCards.length);
    
    // 각 카드의 기술스택 이름 추출 및 상태 업데이트
    var updatedCards = 0;
    for (var i = 0; i < allCards.length; i++) {
        var card = allCards[i];
        var techStack = "";
        
        try {
            // 방법 1: label 요소의 텍스트
            var label = card.querySelector('label');
            if (label && label.textContent) {
                techStack = label.textContent.trim();
            }
            
            // 방법 2: value 속성
            if (!techStack && card.value) {
                techStack = card.value.trim();
            }
            
            // 방법 3: data 속성들
            if (!techStack) {
                var dataAttrs = ['data-techstack', 'data-value', 'data-name'];
                for (var d = 0; d < dataAttrs.length; d++) {
                    var attrValue = card.getAttribute(dataAttrs[d]);
                    if (attrValue) {
                        techStack = attrValue.trim();
                        break;
                    }
                }
            }
            
            // 방법 4: 텍스트 내용 직접 추출
            if (!techStack && card.textContent) {
                var textContent = card.textContent.trim();
                var techStackNames = ["Java", "JavaScript", "Python", "React", "Spring Boot", "Node.js", 
                                     "MySQL", "MongoDB", "Docker", "Kubernetes", "Vue.js", "Angular"];
                
                for (var t = 0; t < techStackNames.length; t++) {
                    if (textContent.indexOf(techStackNames[t]) !== -1) {
                        techStack = techStackNames[t];
                        break;
                    }
                }
            }
            
            scwin.debugLog("카드 " + i + " - 기술스택:", techStack);
            
            // 상태 업데이트
            if (techStack) {
                var isSelected = selectedTechStacks.indexOf(techStack) !== -1;
                
                if (isSelected) {
                    card.classList.add('selected');
                    scwin.debugLog("✅ 카드 선택 상태로 변경:", techStack);
                } else {
                    card.classList.remove('selected');
                    scwin.debugLog("❌ 카드 선택 해제 상태로 변경:", techStack);
                }
                
                updatedCards++;
            } else {
                scwin.debugLog("⚠️ 기술스택 이름을 추출하지 못한 카드");
            }
            
        } catch (error) {
            console.error("카드 처리 중 오류:", error, card);
        }
    }
    
    scwin.debugLog("상태 업데이트된 카드 개수:", updatedCards);
    scwin.debugLog("=== 카드 상태 업데이트 완료 ===");
};

// 개별 기술스택 제거 함수 (Generator 내부에서 호출) - 타입에러 해결
scwin.removeTechStackByIndex = function(rowIndex) {
    console.log("=== 기술스택 제거 시작 ===");
    console.log("제거할 행 인덱스:", rowIndex);
    
    try {
        // 현재 데이터 확인
        console.log("제거 전 기술스택 개수:", dlt_techstack.getRowCount());
        
        if (rowIndex >= 0 && rowIndex < dlt_techstack.getRowCount()) {
            var techstack = dlt_techstack.getCellData(rowIndex, "techstack");
            console.log("제거할 기술스택:", techstack);
            
            // 데이터리스트에서 해당 행 삭제
            dlt_techstack.removeRow(rowIndex);
            
            console.log("제거 후 기술스택 개수:", dlt_techstack.getRowCount());
            
            // Generator 강제 새로고침
            try {
                gen_techstack.refresh();
                console.log("Generator 새로고침 완료");
            } catch (error) {
                console.error("Generator 새로고침 오류:", error);
            }
            
            // 카드 상태 업데이트
            setTimeout(function() {
                scwin.updateTechStackCards();
            }, 200);
            
            console.log("기술스택 제거 완료:", techstack);
        } else {
            console.error("잘못된 행 인덱스:", rowIndex);
        }
        
    } catch (error) {
        console.error("기술스택 제거 중 오류:", error);
    }
    
    console.log("=== 기술스택 제거 완료 ===");
};

// 기존 함수는 호환성을 위해 유지
scwin.removeTechStack = function(rowIndex) {
    scwin.removeTechStackByIndex(rowIndex);
};

// 성향 버튼 클릭 이벤트 - 4개 제한 먼저 확인하도록 수정
scwin.personality_btn_onclick = function (e) {
    console.log("=== 성향 버튼 클릭 이벤트 시작 ===");
    
    // 이벤트 전파 방지
    if (e) {
        e.preventDefault();
        e.stopPropagation();
    }
    
    // 먼저 4개 제한 확인 (성향 인식 전에)
    if (scwin.selectedPersonalities.length >= scwin.maxPersonalities) {
        // 선택된 성향이 이미 4개인 경우, 클릭한 버튼이 이미 선택된 것인지만 확인
        var clickedElement = e.target || e.srcElement;
        var isClickedSelected = false;
        
        // 클릭된 버튼이 선택된 상태인지 빠르게 확인
        var currentElement = clickedElement;
        var depth = 0;
        while (currentElement && depth < 5) {
            if (currentElement.classList && currentElement.classList.contains('selected')) {
                isClickedSelected = true;
                break;
            }
            currentElement = currentElement.parentNode;
            depth++;
        }
        
        // 선택되지 않은 버튼을 클릭한 경우 즉시 차단
        if (!isClickedSelected) {
            alert("최대 " + scwin.maxPersonalities + "개까지만 선택 가능합니다.");
            return;
        }
    }
    
    var personality = "";
    var btn = null;
    var eventSource = e.target || e.srcElement;
    
    console.log("=== 이벤트 소스 디버깅 ===");
    console.log("태그명:", eventSource.tagName);
    console.log("ID:", eventSource.id);
    console.log("클래스:", eventSource.className);
    console.log("텍스트 내용:", eventSource.textContent);
    console.log("HTML (처음 300자):", eventSource.outerHTML.substring(0, 300));
    
    // 모든 가능한 방법으로 성향과 버튼 찾기
    var methods = [
        // 방법 1: 직접 라벨에서 성향 텍스트 추출
        function() {
            try {
                var label = eventSource.querySelector('label');
                if (label && label.textContent) {
                    var text = label.textContent.trim();
                    if (/^[ABCD][RIT][STF][DF]$/.test(text)) {
                        personality = text;
                        btn = eventSource;
                        return true;
                    }
                }
            } catch (error) {
                console.log("방법1 오류:", error);
            }
            return false;
        },
        
        // 방법 2: 이벤트 소스가 라벨인 경우
        function() {
            try {
                if (eventSource.tagName === 'LABEL') {
                    var text = eventSource.textContent.trim();
                    if (/^[ABCD][RIT][STF][DF]$/.test(text)) {
                        personality = text;
                        btn = eventSource.parentNode;
                        return true;
                    }
                }
            } catch (error) {
                console.log("방법2 오류:", error);
            }
            return false;
        },
        
        // 방법 3: 광범위한 상위 요소 탐색
        function() {
            try {
                var currentElement = eventSource;
                var maxDepth = 15; // 더 깊이 탐색
                var depth = 0;
                
                while (currentElement && depth < maxDepth) {
                    console.log("탐색 레벨 " + depth + ":", currentElement.tagName, currentElement.id, currentElement.className);
                    
                    // 현재 요소에서 라벨 찾기
                    var labels = currentElement.querySelectorAll('label');
                    for (var i = 0; i < labels.length; i++) {
                        var labelText = labels[i].textContent.trim();
                        if (/^[ABCD][RIT][STF][DF]$/.test(labelText)) {
                            personality = labelText;
                            btn = currentElement;
                            console.log("상위 탐색에서 발견 - 레벨:", depth, "성향:", personality);
                            return true;
                        }
                    }
                    
                    // 현재 요소가 성향 버튼인지 확인
                    if (currentElement.classList && (
                        currentElement.classList.contains('personality-btn') ||
                        currentElement.className.indexOf('personality') !== -1
                    )) {
                        var selfLabel = currentElement.querySelector('label');
                        if (selfLabel && selfLabel.textContent) {
                            var selfText = selfLabel.textContent.trim();
                            if (/^[ABCD][RIT][STF][DF]$/.test(selfText)) {
                                personality = selfText;
                                btn = currentElement;
                                console.log("성향 버튼에서 발견:", personality);
                                return true;
                            }
                        }
                    }
                    
                    // ID에서 성향 추출 시도
                    if (currentElement.id) {
                        var personalityFromId = "";
                        if (currentElement.id.indexOf('personality_') !== -1) {
                            personalityFromId = currentElement.id.replace(/.*personality_/, '');
                        } else if (currentElement.id.indexOf('mf_personality_') !== -1) {
                            personalityFromId = currentElement.id.replace(/.*mf_personality_/, '');
                        }
                        
                        if (personalityFromId && /^[ABCD][RIT][STF][DF]$/.test(personalityFromId)) {
                            personality = personalityFromId;
                            btn = currentElement;
                            console.log("ID에서 발견:", personality);
                            return true;
                        }
                    }
                    
                    currentElement = currentElement.parentNode;
                    depth++;
                }
            } catch (error) {
                console.log("방법3 오류:", error);
            }
            return false;
        },
        
        // 방법 4: 전체 문서에서 성향 버튼 찾아서 매칭
        function() {
            try {
                console.log("=== 전체 문서에서 성향 버튼 찾기 ===");
                
                // 모든 가능한 성향 버튼 선택자
                var selectors = [
                    '.personality-btn',
                    '[class*="personality"]',
                    '[id*="personality"]',
                    'input[type="button"]',
                    'xf\\:trigger',
                    '*[class*="btn"]'
                ];
                
                var allButtons = [];
                
                for (var s = 0; s < selectors.length; s++) {
                    try {
                        var found = document.querySelectorAll(selectors[s]);
                        for (var f = 0; f < found.length; f++) {
                            // 중복 제거
                            var isDuplicate = false;
                            for (var a = 0; a < allButtons.length; a++) {
                                if (allButtons[a] === found[f]) {
                                    isDuplicate = true;
                                    break;
                                }
                            }
                            if (!isDuplicate) {
                                allButtons.push(found[f]);
                            }
                        }
                    } catch (selectorError) {
                        console.log("선택자 오류:", selectors[s], selectorError);
                    }
                }
                
                console.log("전체 찾은 버튼:", allButtons.length);
                
                // 각 버튼을 검사해서 클릭된 것 찾기
                for (var i = 0; i < allButtons.length; i++) {
                    var button = allButtons[i];
                    
                    // 클릭된 요소가 이 버튼이거나 하위 요소인지 확인
                    if (button === eventSource || button.contains(eventSource) || eventSource.contains(button)) {
                        console.log("매칭된 버튼 검사:", button.id, button.className);
                        
                        // 이 버튼에서 성향 추출
                        var buttonLabel = button.querySelector('label');
                        if (buttonLabel && buttonLabel.textContent) {
                            var buttonText = buttonLabel.textContent.trim();
                            if (/^[ABCD][RIT][STF][DF]$/.test(buttonText)) {
                                personality = buttonText;
                                btn = button;
                                console.log("매칭에서 발견:", personality);
                                return true;
                            }
                        }
                        
                        // 버튼의 텍스트 내용에서 성향 패턴 찾기
                        var allText = button.textContent || "";
                        var matches = allText.match(/[ABCD][RIT][STF][DF]/g);
                        if (matches && matches.length > 0) {
                            personality = matches[0];
                            btn = button;
                            console.log("텍스트 패턴에서 발견:", personality);
                            return true;
                        }
                    }
                }
            } catch (error) {
                console.log("방법4 오류:", error);
            }
            return false;
        },
        
        // 방법 5: 텍스트 기반 무차별 검색
        function() {
            try {
                // 클릭 위치 주변의 모든 텍스트에서 성향 패턴 찾기
                var searchElements = [eventSource];
                
                // 부모들도 추가
                var parent = eventSource.parentNode;
                var depth = 0;
                while (parent && depth < 10) {
                    searchElements.push(parent);
                    parent = parent.parentNode;
                    depth++;
                }
                
                // 자식들도 추가
                var descendants = eventSource.querySelectorAll('*');
                for (var d = 0; d < descendants.length; d++) {
                    searchElements.push(descendants[d]);
                }
                
                for (var e = 0; e < searchElements.length; e++) {
                    var element = searchElements[e];
                    var textContent = element.textContent || "";
                    var matches = textContent.match(/[ABCD][RIT][STF][DF]/g);
                    
                    if (matches && matches.length > 0) {
                        personality = matches[0];
                        btn = element.closest('.personality-btn') || 
                             element.closest('[class*="personality"]') || 
                             element.closest('[id*="personality"]') || 
                             element;
                        console.log("무차별 검색에서 발견:", personality);
                        return true;
                    }
                }
            } catch (error) {
                console.log("방법5 오류:", error);
            }
            return false;
        }
    ];
    
    // 각 방법을 차례로 시도
    var methodFound = false;
    for (var m = 0; m < methods.length; m++) {
        console.log("방법 " + (m + 1) + " 시도 중...");
        if (methods[m]()) {
            console.log("✅ 방법 " + (m + 1) + " 성공!");
            methodFound = true;
            break;
        }
    }
    
    console.log("=== 최종 결과 ===");
    console.log("추출된 성향:", personality);
    console.log("찾은 버튼:", btn);
    console.log("방법 성공 여부:", methodFound);
    
    // 성향을 찾지 못한 경우
    if (!personality || personality === "") {
        console.error("❌ 모든 방법으로 성향을 찾지 못했습니다");
        console.error("=== 추가 디버깅 정보 ===");
        console.error("이벤트 타입:", e.type);
        console.error("이벤트 대상:", e.target);
        console.error("현재 타겟:", e.currentTarget);
        console.error("버블링 경로:");
        
        var path = e.path || (e.composedPath && e.composedPath()) || [];
        for (var p = 0; p < Math.min(path.length, 10); p++) {
            if (path[p].tagName) {
                console.error("  " + p + ":", path[p].tagName, path[p].id, path[p].className);
            }
        }
        
        alert("성향을 인식할 수 없습니다.\n브라우저 콘솔(F12)에서 상세한 디버깅 정보를 확인해주세요.");
        return;
    }
    
    if (!btn) {
        console.error("❌ 버튼 요소를 찾을 수 없습니다");
        alert("버튼 요소를 찾을 수 없습니다.");
        return;
    }
    
    console.log("✅ 성향 인식 성공:", personality);
    
    // disabled 상태면 클릭 무시
    if (btn.classList.contains('disabled')) {
        alert("최대 " + scwin.maxPersonalities + "개까지만 선택 가능합니다.");
        return;
    }
    
    // 현재 선택 상태 확인 - 배열에서 직접 확인 (가장 확실한 방법)
    var isCurrentlySelected = scwin.selectedPersonalities.indexOf(personality) !== -1;
    console.log("현재 선택 상태 (배열):", isCurrentlySelected);
    console.log("현재 선택된 성향들:", scwin.selectedPersonalities);
    
    if (isCurrentlySelected) {
        // 선택 해제
        console.log("=== 선택 해제 시작 ===");
        
        // 1. 배열에서 제거
        var arrayIndex = scwin.selectedPersonalities.indexOf(personality);
        if (arrayIndex > -1) {
            scwin.selectedPersonalities.splice(arrayIndex, 1);
            console.log("배열에서 제거 완료");
        }
        
        // 2. 데이터리스트에서 제거
        for (var i = dlt_personalities.getRowCount() - 1; i >= 0; i--) {
            var dataPersonality = dlt_personalities.getCellData(i, "personality");
            if (dataPersonality === personality) {
                dlt_personalities.removeRow(i);
                console.log("데이터리스트에서 제거 완료");
            }
        }
        
        // 3. UI 클래스 제거
        btn.classList.remove('selected');
        console.log("UI 클래스 제거 완료");
        
        console.log("✅ 성향 선택 해제:", personality);
    } else {
        // 선택 추가 - 4개 제한 확인
        if (scwin.selectedPersonalities.length >= scwin.maxPersonalities) {
            alert("최대 " + scwin.maxPersonalities + "개까지만 선택 가능합니다.");
            return;
        }
        
        console.log("=== 선택 추가 시작 ===");
        
        // 1. 배열에 추가
        scwin.selectedPersonalities.push(personality);
        console.log("배열에 추가 완료");
        
        // 2. 데이터리스트에 추가
        var newRowIndex = dlt_personalities.insertRow();
        dlt_personalities.setCellData(newRowIndex, "personality", personality);
        console.log("데이터리스트에 추가 완료");
        
        // 3. UI 클래스 추가
        btn.classList.add('selected');
        console.log("UI 클래스 추가 완료");
        
        console.log("✅ 성향 선택:", personality);
    }
    
    // 상태 업데이트
    scwin.updatePersonalityCounter();
    scwin.updatePersonalityButtons();
    
    console.log("=== 업데이트 후 상태 ===");
    console.log("선택된 성향들:", scwin.selectedPersonalities);
    console.log("데이터리스트 개수:", dlt_personalities.getRowCount());
    console.log("=== 성향 버튼 클릭 이벤트 완료 ===");
};

// 성향을 데이터리스트에 추가 (개선된 버전)
scwin.addPersonalityToData = function(personality) {
    if (!personality || personality.trim() === "") return;
    
    console.log("성향 추가 시작:", personality);
    
    // 배열에 추가 (중복 체크)
    if (scwin.selectedPersonalities.indexOf(personality) === -1) {
        scwin.selectedPersonalities.push(personality);
        console.log("배열에 추가됨:", personality);
    }
    
    // 데이터리스트에 추가 (중복 체크)
    var matchedData = dlt_personalities.getMatchedJSON("personality", personality);
    if (matchedData.length == 0) {
        var newRowIndex = dlt_personalities.insertRow();
        dlt_personalities.setCellData(newRowIndex, "personality", personality);
        console.log("데이터리스트에 추가됨:", personality);
    }
    
    console.log("성향 추가 완료 - 배열 길이:", scwin.selectedPersonalities.length, "데이터 개수:", dlt_personalities.getRowCount());
};

// 성향을 데이터리스트에서 제거 (개선된 버전)
scwin.removePersonalityFromData = function(personality) {
    if (!personality || personality.trim() === "") return;
    
    console.log("성향 제거 시작:", personality);
    
    // 배열에서 제거
    var index = scwin.selectedPersonalities.indexOf(personality);
    if (index > -1) {
        scwin.selectedPersonalities.splice(index, 1);
        console.log("배열에서 제거됨:", personality);
    }
    
    // 데이터리스트에서 제거
    var matchedData = dlt_personalities.getMatchedJSON("personality", personality);
    if (matchedData.length > 0) {
        for (var i = 0; i < matchedData.length; i++) {
            var rowIndex = dlt_personalities.getRowIndex(matchedData[i]);
            dlt_personalities.removeRow(rowIndex);
        }
        console.log("데이터리스트에서 제거됨:", personality);
    }
    
    console.log("성향 제거 완료 - 배열 길이:", scwin.selectedPersonalities.length, "데이터 개수:", dlt_personalities.getRowCount());
};

// 성향 카운터 업데이트 - 로그 정리
scwin.updatePersonalityCounter = function() {
    var counter = document.querySelector('.personality-counter');
    if (!counter) {
        // 카운터 엘리먼트가 없으면 생성
        var section = document.querySelector('.personality-section');
        if (section) {
            counter = document.createElement('div');
            counter.className = 'personality-counter';
            section.style.position = 'relative';
            section.appendChild(counter);
        }
    }
    
    if (counter) {
        var selectedCount = scwin.selectedPersonalities.length;
        counter.textContent = selectedCount + '/' + scwin.maxPersonalities;
        
        scwin.debugLog("성향 카운터 업데이트:", selectedCount + '/' + scwin.maxPersonalities);
        
        // 카운터 색상 변경
        if (selectedCount >= scwin.maxPersonalities) {
            counter.style.background = 'linear-gradient(135deg, #e53e3e, #c53030)';
        } else {
            counter.style.background = 'linear-gradient(135deg, #ed8936, #dd6b20)';
        }
        
        // 강제로 보이게 하기
        counter.style.display = 'block';
        counter.style.visibility = 'visible';
    }
};

// 성향 버튼 상태 업데이트 - 로그 정리
scwin.updatePersonalityButtons = function() {
    var selectedCount = scwin.selectedPersonalities.length;
    
    scwin.debugLog("=== 성향 버튼 상태 업데이트 시작 ===");
    scwin.debugLog("선택된 개수:", selectedCount);
    scwin.debugLog("선택된 성향들:", scwin.selectedPersonalities);
    
    // 모든 가능한 선택자로 성향 버튼 찾기
    var personalitySelectors = [
        '.personality-btn',
        '[class*="personality"]',
        '[id*="personality"]',
        'xf\\:trigger[class*="personality"]',
        'input[class*="personality"]'
    ];
    
    var allButtons = [];
    
    // 각 선택자로 요소 찾기
    for (var s = 0; s < personalitySelectors.length; s++) {
        try {
            var foundElements = document.querySelectorAll(personalitySelectors[s]);
            scwin.debugLog("선택자 '" + personalitySelectors[s] + "'로 찾은 버튼:", foundElements.length);
            
            for (var e = 0; e < foundElements.length; e++) {
                var element = foundElements[e];
                // 중복 제거
                var isDuplicate = false;
                for (var b = 0; b < allButtons.length; b++) {
                    if (allButtons[b] === element) {
                        isDuplicate = true;
                        break;
                    }
                }
                
                if (!isDuplicate) {
                    allButtons.push(element);
                }
            }
        } catch (error) {
            scwin.debugLog("선택자 '" + personalitySelectors[s] + "' 사용 중 오류:", error);
        }
    }
    
    scwin.debugLog("총 찾은 버튼 개수:", allButtons.length);
    
    // 각 버튼의 성향 추출 및 상태 업데이트
    var updatedButtons = 0;
    for (var i = 0; i < allButtons.length; i++) {
        var btn = allButtons[i];
        var personality = "";
        
        try {
            // 방법 1: label 요소의 텍스트
            var label = btn.querySelector('label');
            if (label && label.textContent) {
                personality = label.textContent.trim();
            }
            
            // 방법 2: ID에서 추출
            if (!personality && btn.id) {
                if (btn.id.indexOf('mf_personality_') === 0) {
                    personality = btn.id.replace('mf_personality_', '');
                } else if (btn.id.indexOf('personality_') === 0) {
                    personality = btn.id.replace('personality_', '');
                }
            }
            
            // 방법 3: 텍스트 내용에서 성향 패턴 추출
            if (!personality && btn.textContent) {
                var textContent = btn.textContent.toUpperCase();
                var personalityPattern = /([ABCD][RIT][STF][DF])/g;
                var matches = textContent.match(personalityPattern);
                
                if (matches && matches.length > 0) {
                    personality = matches[0];
                }
            }
            
            scwin.debugLog("버튼 " + i + " - 성향:", personality);
            
            if (personality) {
                // 현재 이 성향이 선택되어 있는지 확인
                var isSelectedInArray = scwin.selectedPersonalities.indexOf(personality) !== -1;
                
                scwin.debugLog("성향 " + personality + " 선택됨:", isSelectedInArray);
                
                // UI 상태 동기화
                if (isSelectedInArray) {
                    btn.classList.add('selected');
                    scwin.debugLog("✅ 버튼 선택 상태로 변경:", personality);
                } else {
                    btn.classList.remove('selected');
                    scwin.debugLog("❌ 버튼 선택 해제 상태로 변경:", personality);
                }
                
                // 비활성화 처리
                if (!isSelectedInArray && selectedCount >= scwin.maxPersonalities) {
                    btn.classList.add('disabled');
                    scwin.debugLog("������ 버튼 비활성화:", personality);
                } else {
                    btn.classList.remove('disabled');
                    scwin.debugLog("✅ 버튼 활성화:", personality);
                }
                
                updatedButtons++;
            } else {
                scwin.debugLog("⚠️ 성향을 추출하지 못한 버튼");
            }
            
        } catch (error) {
            console.error("버튼 처리 중 오류:", error, btn);
        }
    }
    
    scwin.debugLog("상태 업데이트된 버튼 개수:", updatedButtons);
    scwin.debugLog("=== 성향 버튼 상태 업데이트 완료 ===");
};

scwin.btn_cancel_posting_onclick = function (e) {
    if (window.history.length > 1) {
        window.history.back();          
    } 
    else {
        $p.url("RecruitmentDashboard.xml");
    }
};

scwin.btn_create_posting_onclick = function (e) {
    console.log("=== 등록 버튼 클릭됨 ===");
    
    // 필수 값들 검증
    if (!dmp_postVo.get("title") || dmp_postVo.get("title").trim() === "") {
        alert("공고 제목을 입력해주세요.");
        return;
    }
    
    if (!dmp_postVo.get("location") || dmp_postVo.get("location").trim() === "") {
        alert("근무 지역을 선택해주세요.");
        return;
    }
    
    if (!dmp_postVo.get("workType") || dmp_postVo.get("workType").trim() === "") {
        alert("근무 형태를 선택해주세요.");
        return;
    }
    
    // 기술스택 필수 선택 검증 추가
    if (dlt_techstack.getRowCount() === 0) {
        alert("최소 1개 이상의 기술스택을 선택해주세요.");
        return;
    }
    
    // 성향 필수 선택 검증 추가 (배열과 데이터리스트 모두 확인)
    var personalityCount = dlt_personalities.getRowCount();
    var arrayCount = scwin.selectedPersonalities ? scwin.selectedPersonalities.length : 0;
    
    console.log("성향 검증 - 데이터리스트 개수:", personalityCount, "배열 개수:", arrayCount);
    
    if (personalityCount === 0 && arrayCount === 0) {
        alert("최소 1개 이상의 선호 성향을 선택해주세요.");
        return;
    }
    
    if (!dmp_postVo.get("description") || dmp_postVo.get("description").trim() === "") {
        alert("인재상 상세 설명을 입력해주세요.");
        return;
    }
    
    console.log("=== 모든 필수 필드 검증 통과 ===");
    
    // 기본 confirm으로 확인
    if (confirm("공고를 등록하시겠습니까?")) {
        console.log("=== 사용자가 확인 버튼 클릭 ===");
        
        // 기본 값들 설정
        var currentDate = new Date();
        var dateString = currentDate.getFullYear() + '-' + 
                         String(currentDate.getMonth() + 1).padStart(2, '0') + '-' + 
                         String(currentDate.getDate()).padStart(2, '0') + ' ' +
                         String(currentDate.getHours()).padStart(2, '0') + ':' +
                         String(currentDate.getMinutes()).padStart(2, '0') + ':' +
                         String(currentDate.getSeconds()).padStart(2, '0');
        
        // 만료일 설정 (30일 후)
        var expiryDate = new Date(currentDate);
        expiryDate.setDate(expiryDate.getDate() + 30);
        var expiryString = expiryDate.getFullYear() + '-' + 
                          String(expiryDate.getMonth() + 1).padStart(2, '0') + '-' + 
                          String(expiryDate.getDate()).padStart(2, '0') + ' ' +
                          String(expiryDate.getHours()).padStart(2, '0') + ':' +
                          String(expiryDate.getMinutes()).padStart(2, '0') + ':' +
                          String(expiryDate.getSeconds()).padStart(2, '0');
        
        console.log("=== 날짜 설정 완료 ===");
        console.log("현재시간:", dateString);
        console.log("만료시간:", expiryString);
        
        // 데이터 설정 (job_posting_id는 AUTO_INCREMENT이므로 제외)
        dmp_postVo.set("companyId", 1); // 숫자로 설정 (실제로는 로그인 사용자의 회사 ID)
        dmp_postVo.set("postedAt", dateString);
        dmp_postVo.set("expiresAt", expiryString);
        dmp_postVo.set("status", "active"); // ENUM 값에 맞게 소문자
        
        // 선택된 기술스택들을 JSON 배열로 변환하여 selectedTechStackNames에 저장
        var techStackArray = [];
        for(var i = 0; i < dlt_techstack.getRowCount(); i++) {
            var techstack = dlt_techstack.getCellData(i, "techstack");
            if (techstack && techstack.trim() !== "") {
                techStackArray.push(techstack);
            }
        }
        dmp_postVo.set("selectedTechStackNames", JSON.stringify(techStackArray)); // JSON 문자열로 저장
        
        // 선택된 성향들을 JSON 배열로 변환하여 preferredDeveloperTypes에 저장 (수정된 부분)
        var personalityArray = [];
        for(var i = 0; i < dlt_personalities.getRowCount(); i++) {
            var personality = dlt_personalities.getCellData(i, "personality");
            if (personality && personality.trim() !== "") {
                personalityArray.push(personality);
            }
        }
        dmp_postVo.set("preferredDeveloperTypes", JSON.stringify(personalityArray)); // JSON 문자열로 저장
        
        console.log("등록할 데이터 - 제목:", dmp_postVo.get("title"));
        console.log("등록할 데이터 - 지역:", dmp_postVo.get("location"));
        console.log("등록할 데이터 - 기술스택:", dmp_postVo.get("selectedTechStackNames"));
        console.log("등록할 데이터 - 성향:", dmp_postVo.get("preferredDeveloperTypes"));
        console.log("등록할 데이터 - 상태:", dmp_postVo.get("status"));
        
        console.log("=== 서버 통신 시작 ===");
        
        // 웹스퀘어 submission 실행
        try {
            var submission = $p.getComponentById("sbm_insertPost");
            if (submission) {
                // 여러 방법 시도
                var success = false;
                
                // 방법 1: 표준 웹스퀘어 API
                try {
                    $p.executeSubmission("sbm_insertPost");
                    success = true;
                    console.log("✅ submission 실행 성공");
                } catch (error1) {
                    console.log("방법1 실패:", error1.message);
                    
                    // 방법 2: DOM 이벤트 트리거
                    try {
                        var submitEvent = document.createEvent('Event');
                        submitEvent.initEvent('submit', true, true);
                        submission.xmlNode.dispatchEvent(submitEvent);
                        success = true;
                        console.log("✅ DOM 이벤트 트리거 성공");
                    } catch (error2) {
                        console.log("방법2 실패:", error2.message);
                        throw new Error("모든 submission 실행 방법 실패");
                    }
                }
                
                if (success) {
                    console.log("=== submission 실행 완료 - 서버 응답 대기 중 ===");
                }
                
            } else {
                throw new Error("submission 객체를 찾을 수 없습니다");
            }
            
        } catch (error) {
            console.error("submission 실행 최종 오류:", error);
            alert("서버 통신 중 오류가 발생했습니다: " + error.message);
        }
    } else {
        console.log("=== 사용자가 취소 버튼 클릭 ===");
    }
};

scwin.sbm_insertPost_submitdone = function(e) {
    console.log("=== 서버 응답 수신 ===");
    console.log("응답 전체:", e);
    console.log("응답 JSON:", e.responseJSON);
    
    // error 수신시
    var elHeader = e.responseJSON ? e.responseJSON.elHeader : null;
    console.log("elHeader:", elHeader);
    
    if(elHeader == null || elHeader == "" || elHeader == "undefined" || elHeader.resSuc == false) {
        var errorCode = elHeader ? elHeader.resCode : "Unknown";
        var errorMsg = elHeader ? elHeader.resMsg : "서버 응답 없음";
        
        console.error("서버 에러 - 코드:", errorCode, "메시지:", errorMsg);
        alert(`에러코드 : ${errorCode}\n에러메시지 : ${errorMsg}`);
        return false;
    } else {
        console.log("=== 등록 성공 ===");
        // 등록되었습니다. msg 출력
        alert("공고가 등록되었습니다.");
        // 등록 후 대시보드로 이동
        $p.url("../corporate/RecruitmentDashboard.xml");
    }
};
]]></script>
    </head>
    <body ev:onpageload="scwin.onpageload">
        <!-- 배경 장식 요소 -->
        <xf:group class="background-decoration">
            <xf:group class="floating-shape shape-1"></xf:group>
            <xf:group class="floating-shape shape-2"></xf:group>
            <xf:group class="floating-shape shape-3"></xf:group>
            <xf:group class="floating-shape shape-4"></xf:group>
        </xf:group>
        
        <xf:group class="main-container">
            <xf:group class="content-container">
                <!-- 페이지 헤더 -->
                <xf:group class="page-header">
                    <w2:textbox class="header-icon" label="🚀"></w2:textbox>
                    <w2:textbox class="main-title" label="공고 등록"></w2:textbox>
                    <w2:textbox class="page-subtitle" label="우리 회사의 문화와 원하는 인재상을 입력해주세요"></w2:textbox>
                </xf:group>

                <!-- 기본 정보 섹션 -->
                <section class="form-section">
                    <w2:textbox class="section-title" label="📝 기본 정보">
                        <xf:group class="section-icon">📝</xf:group>
                    </w2:textbox>
                    
                    <xf:group class="form-group">
                        <w2:textbox class="form-label required" label="공고 제목"></w2:textbox>
                        <xf:input class="form-input" placeholder="매력적인 공고 제목을 입력해주세요" ref="data:dmp_postVo.title"></xf:input>
                    </xf:group>
                    
                    <xf:group class="form-row">
                        <xf:group class="form-group half">
                            <w2:textbox class="form-label required" label="근무 지역"></w2:textbox>
                            <xf:select1 class="form-select" chooseOption="지역 선택" appearance="minimal" ref="data:dmp_postVo.location">
                                <xf:choices>
                                    <xf:item>
                                        <xf:label><![CDATA[서울]]></xf:label>
                                        <xf:value><![CDATA[서울]]></xf:value>
                                    </xf:item>
                                    <xf:item>
                                        <xf:label><![CDATA[경기]]></xf:label>
                                        <xf:value><![CDATA[경기]]></xf:value>
                                    </xf:item>
                                    <xf:item>
                                        <xf:label><![CDATA[인천]]></xf:label>
                                        <xf:value><![CDATA[인천]]></xf:value>
                                    </xf:item>
                                    <xf:item>
                                        <xf:label><![CDATA[부산]]></xf:label>
                                        <xf:value><![CDATA[부산]]></xf:value>
                                    </xf:item>
                                    <xf:item>
                                        <xf:label><![CDATA[대구]]></xf:label>
                                        <xf:value><![CDATA[대구]]></xf:value>
                                    </xf:item>
                                    <xf:item>
                                        <xf:label><![CDATA[대전]]></xf:label>
                                        <xf:value><![CDATA[대전]]></xf:value>
                                    </xf:item>
                                    <xf:item>
                                        <xf:label><![CDATA[광주]]></xf:label>
                                        <xf:value><![CDATA[광주]]></xf:value>
                                    </xf:item>                                   
                                </xf:choices>
                            </xf:select1>
                        </xf:group>
                        
                        <xf:group class="form-group half">
                            <w2:textbox class="form-label required" label="근무 형태"></w2:textbox>
                            <xf:select1 class="form-select" chooseOption="형태 선택" appearance="minimal" ref="data:dmp_postVo.workType">
                                <xf:choices>
                                    <xf:item>
                                        <xf:label><![CDATA[원격 근무]]></xf:label>
                                        <xf:value><![CDATA[remote]]></xf:value>
                                    </xf:item>
                                    <xf:item>
                                        <xf:label><![CDATA[출근 근무]]></xf:label>
                                        <xf:value><![CDATA[onsite]]></xf:value>
                                    </xf:item>
                                    <xf:item>
                                        <xf:label><![CDATA[하이브리드]]></xf:label>
                                        <xf:value><![CDATA[hybrid]]></xf:value>
                                    </xf:item>
                                </xf:choices>
                            </xf:select1>
                        </xf:group>
                    </xf:group>
                </section>

                <!-- 개발 환경 및 기술 스택 섹션 -->
                <section class="form-section">
                    <w2:textbox class="section-title" label="💻 개발 환경 및 기술 스택">
                        <xf:group class="section-icon">💻</xf:group>
                    </w2:textbox>

                    <xf:group class="form-group">
                        <w2:textbox class="form-label required" label="주요 기술 스택"></w2:textbox>
                        
                        <!-- 인기 기술스택 카드 선택 -->
                        <w2:textbox class="help-text" label="클릭하여 빠르게 선택하거나, 아래 입력창에 직접 입력하세요. 입력하면 자동완성 추천이 표시됩니다. (예: 'J' 입력 → Java, JavaScript 추천)"></w2:textbox>
                        
                        <xf:group class="techstack-grid">
                            <!-- 기술스택 카드들은 JavaScript에서 동적으로 생성됩니다 -->
                        </xf:group>
                        
                        <!-- 자동완성 입력 - 추천 목록 기능 추가 -->
                        <xf:group style="display: flex; gap: 10px; align-items: flex-start; position: relative;">
                            <xf:group style="flex: 1; position: relative;">
                                <xf:input class="form-input" id="input_techstack" placeholder="기술스택을 입력하세요 (예: React, Java, Docker)" style="width: 100%;" ref="" ev:oninput="scwin.input_techstack_oninput" ev:onfocus="scwin.input_techstack_onfocus" ev:onblur="scwin.input_techstack_onblur" ev:onkeypress="scwin.input_techstack_onkeypress"></xf:input>
                                <!-- 자동완성 추천 목록 -->
                                <div id="techstack-suggestions" class="techstack-suggestions" style="display: none;"></div>
                            </xf:group>
                            <xf:trigger class="btn-add-techstack" type="button" style="height: 56px; padding: 0 20px; background: linear-gradient(135deg, #48bb78, #38a169); color: white; border: none; border-radius: 12px; font-weight: 600; cursor: pointer;" ev:onclick="scwin.addTechStackFromInput">
                                <xf:label><![CDATA[추가]]></xf:label>
                            </xf:trigger>
                        </xf:group>

                        <!-- 선택된 기술스택 표시 영역 (Generator 사용) -->
                        <xf:group class="selected-techstack-container">
                            <w2:generator id="gen_techstack" dataList="data:dlt_techstack" style="display: contents;">
                                <xf:group class="techstack-tag" text="">
                                    <w2:textbox class="techstack-text" id="" label="" ref="data:dlt_techstack.techstack"></w2:textbox>
                                    <xf:trigger class="techstack-remove-btn" type="button"
                                        ev:onclick="scwin.removeTechStackByIndex($index);">
                                        <xf:label><![CDATA[×]]></xf:label>
                                    </xf:trigger>
                                </xf:group>
                            </w2:generator>
                        </xf:group>
                    </xf:group>
                </section>

                <!-- 원하는 인재상 섹션 -->
                <section class="form-section">
                    <w2:textbox class="section-title" label="🎯 원하는 인재상">
                        <xf:group class="section-icon">🎯</xf:group>
                    </w2:textbox>

                    <xf:group class="form-group personality-section" style="position: relative;">
                        <w2:textbox class="form-label" label="선호하는 성향 유형 (최대 4개 선택 가능)"></w2:textbox>
                        <div class="personality-counter">0/4</div>

                        <xf:group class="personality-grid">
                            <!-- BR** -->
                            <xf:trigger class="personality-btn" type="button" id="personality_BRSD" ev:onclick="scwin.personality_btn_onclick">
                                <xf:label><![CDATA[BRSD]]></xf:label>
                            </xf:trigger>
                            <xf:trigger class="personality-btn" type="button" id="personality_BRSF" ev:onclick="scwin.personality_btn_onclick">
                                <xf:label><![CDATA[BRSF]]></xf:label>
                            </xf:trigger>
                            <xf:trigger class="personality-btn" type="button" id="personality_BRTD" ev:onclick="scwin.personality_btn_onclick">
                                <xf:label><![CDATA[BRTD]]></xf:label>
                            </xf:trigger>
                            <xf:trigger class="personality-btn" type="button" id="personality_BRTF" ev:onclick="scwin.personality_btn_onclick">
                                <xf:label><![CDATA[BRTF]]></xf:label>
                            </xf:trigger>

                            <!-- BI** -->
                            <xf:trigger class="personality-btn" type="button" id="personality_BISD" ev:onclick="scwin.personality_btn_onclick">
                                <xf:label><![CDATA[BISD]]></xf:label>
                            </xf:trigger>
                            <xf:trigger class="personality-btn" type="button" id="personality_BISF" ev:onclick="scwin.personality_btn_onclick">
                                <xf:label><![CDATA[BISF]]></xf:label>
                            </xf:trigger>
                            <xf:trigger class="personality-btn" type="button" id="personality_BITD" ev:onclick="scwin.personality_btn_onclick">
                                <xf:label><![CDATA[BITD]]></xf:label>
                            </xf:trigger>
                            <xf:trigger class="personality-btn" type="button" id="personality_BITF" ev:onclick="scwin.personality_btn_onclick">
                                <xf:label><![CDATA[BITF]]></xf:label>
                            </xf:trigger>

                            <!-- AR** -->
                            <xf:trigger class="personality-btn" type="button" id="personality_ARSD" ev:onclick="scwin.personality_btn_onclick">
                                <xf:label><![CDATA[ARSD]]></xf:label>
                            </xf:trigger>
                            <xf:trigger class="personality-btn" type="button" id="personality_ARSF" ev:onclick="scwin.personality_btn_onclick">
                                <xf:label><![CDATA[ARSF]]></xf:label>
                            </xf:trigger>
                            <xf:trigger class="personality-btn" type="button" id="personality_ARTD" ev:onclick="scwin.personality_btn_onclick">
                                <xf:label><![CDATA[ARTD]]></xf:label>
                            </xf:trigger>
                            <xf:trigger class="personality-btn" type="button" id="personality_ARTF" ev:onclick="scwin.personality_btn_onclick">
                                <xf:label><![CDATA[ARTF]]></xf:label>
                            </xf:trigger>

                            <!-- AI** -->
                            <xf:trigger class="personality-btn" type="button" id="personality_AISD" ev:onclick="scwin.personality_btn_onclick">
                                <xf:label><![CDATA[AISD]]></xf:label>
                            </xf:trigger>
                            <xf:trigger class="personality-btn" type="button" id="personality_AISF" ev:onclick="scwin.personality_btn_onclick">
                                <xf:label><![CDATA[AISF]]></xf:label>
                            </xf:trigger>
                            <xf:trigger class="personality-btn" type="button" id="personality_AITD" ev:onclick="scwin.personality_btn_onclick">
                                <xf:label><![CDATA[AITD]]></xf:label>
                            </xf:trigger>
                            <xf:trigger class="personality-btn" type="button" id="personality_AITF" ev:onclick="scwin.personality_btn_onclick">
                                <xf:label><![CDATA[AITF]]></xf:label>
                            </xf:trigger>
                        </xf:group>

                        <w2:textbox class="help-text" label="우리 팀과 잘 맞을 것 같은 성향 유형을 선택해주세요"></w2:textbox>
                    </xf:group>

                    <xf:group class="form-row">
                        <xf:group class="form-group half">
                            <w2:textbox class="form-label" label="선호 경력"></w2:textbox>
                            <xf:select1 class="form-select" chooseOption="경력 선택" appearance="minimal" ref="data:dmp_postVo.experienceLevel">
                                <xf:choices>
                                    <xf:item>
                                        <xf:label><![CDATA[상관없음]]></xf:label>
                                        <xf:value><![CDATA[any]]></xf:value>
                                    </xf:item>
                                    <xf:item>
                                        <xf:label><![CDATA[신입 (0년)]]></xf:label>
                                        <xf:value><![CDATA[new]]></xf:value>
                                    </xf:item>
                                    <xf:item>
                                        <xf:label><![CDATA[1-2년]]></xf:label>
                                        <xf:value><![CDATA[junior]]></xf:value>
                                    </xf:item>
                                    <xf:item>
                                        <xf:label><![CDATA[3-5년]]></xf:label>
                                        <xf:value><![CDATA[mid]]></xf:value>
                                    </xf:item>
                                    <xf:item>
                                        <xf:label><![CDATA[5년 이상]]></xf:label>
                                        <xf:value><![CDATA[senior]]></xf:value>
                                    </xf:item>
                                </xf:choices>
                            </xf:select1>
                        </xf:group>

                        <xf:group class="form-group half">
                            <w2:textbox class="form-label" label="예상 연봉범위"></w2:textbox>
                            <xf:select1 class="form-select" chooseOption="연봉 선택" appearance="minimal" ref="data:dmp_postVo.salaryRange">
                                <xf:choices>
                                    <xf:item>
                                        <xf:label><![CDATA[2,500만원 미만]]></xf:label>
                                        <xf:value><![CDATA[under25]]></xf:value>
                                    </xf:item>
                                    <xf:item>
                                        <xf:label><![CDATA[2,500-3,500만원]]></xf:label>
                                        <xf:value><![CDATA[25to35]]></xf:value>
                                    </xf:item>
                                    <xf:item>
                                        <xf:label><![CDATA[3,500-5,000만원]]></xf:label>
                                        <xf:value><![CDATA[35to50]]></xf:value>
                                    </xf:item>
                                    <xf:item>
                                        <xf:label><![CDATA[5,000만원 이상]]></xf:label>
                                        <xf:value><![CDATA[over50]]></xf:value>
                                    </xf:item>
                                </xf:choices>
                            </xf:select1>
                        </xf:group>
                    </xf:group>

                    <xf:group class="form-group">
                        <w2:textbox class="form-label required" label="원하는 인재상 상세 설명"></w2:textbox>
                        <xf:textarea class="form-textarea" placeholder="우리 회사에서 함께 일하고 싶은 개발자의 특징이나 역량을 구체적으로 설명해주세요." ref="data:dmp_postVo.description"></xf:textarea>
                    </xf:group>

                    <!-- 버튼 그룹 -->
                    <xf:group class="button-container">
                        <xf:trigger class="btn-cancel" type="button" id="btn_cancel_posting" ev:onclick="scwin.btn_cancel_posting_onclick">
                            <xf:label><![CDATA[취소]]></xf:label>
                        </xf:trigger>
                        <xf:trigger class="btn-primary" type="button" id="btn_create_posting" ev:onclick="scwin.btn_create_posting_onclick">
                            <xf:label><![CDATA[🚀 공고 등록하기]]></xf:label>
                        </xf:trigger>
                    </xf:group>
                </section>
            </xf:group>
        </xf:group>
    </body>
</html>